    <!DOCTYPE html>
    <html lang="en" data-theme="light">
    <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="https://cdn-dynmedia-1.microsoft.com/is/content/microsoftcorp/191343-features-icon-03-28x28?wid=32&hei=32&qlt=100&fit=constrain" />
    <title>Azure Cosmos DB - In a Nutshell</title>
    <meta name="description" content="A comprehensive guide to Azure Cosmos DB." />
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <style>
    :root{
      --bg: #ffffff;
      --fg: #0f172a;
      --muted: #64748b;
      --accent: #3b82f6;
      --accent-light: #dbeafe;
      --border: #e2e8f0;
      --sidebar-bg: #ffffff;
      --sidebar-fg: #0f172a;
      --code-bg: linear-gradient(90deg, rgba(59, 130, 246, 0.08) 0%, rgba(59, 130, 246, 0.12) 100%);
      --focus: #10b981;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
      --shadow-lg: 0 10px 20px rgba(0,0,0,0.12), 0 6px 6px rgba(0,0,0,0.08);
      --gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    }
    
    /* Apply theme colors to Bootstrap elements */
    body { background-color: var(--bg); color: var(--fg); overflow: hidden; }
    .navbar { background-color: var(--fg) !important; border-bottom: none !important; box-shadow: var(--shadow-md) !important; }
    .navbar-brand { cursor: pointer; color: var(--bg) !important; font-weight: 600; letter-spacing: 0px; }
    .navbar-toggler-icon { 
      filter: invert(1);
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%2896, 165, 250, 0.9%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
    }
    
    .btn-outline-secondary { border-color: var(--border) !important; color: var(--fg) !important; }
    .btn-outline-secondary:hover { background-color: var(--accent-light) !important; border-color: var(--accent) !important; color: var(--accent) !important; }
    
    /* Sidebar - Modern Design */
    nav.sidebar { 
      background: linear-gradient(180deg, #f3f4f6 0%, #e5e7eb 100%); 
      border-right: 1px solid rgba(0, 0, 0, 0.05) !important; 
      overflow-y: auto; 
      box-shadow: 4px 0 16px rgba(0, 0, 0, 0.06);
      padding-top: 0;
    }
    
    .menu-header {  
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.1) 100%);
      font-weight: bold; 
      padding: 1.25rem 1.25rem; 
      letter-spacing: 0px; 
      font-size: 1.1rem;
      position: relative;
      overflow: hidden;
      border: none;
      border-bottom: 2px solid #a5aab3;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      color: #0c346c;
      text-shadow: none;
      margin: 0;
      text-transform: none;
    }
    .menu-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      transition: left 0.6s ease;
    }
    .menu-header:hover::before {
      left: 100%;
    }
    .menu-header::after {
      content: 'üìã';
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.3rem;
      opacity: 0.9;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
    }
    
    .toc { 
      list-style: none; 
      padding: 0rem 0; 
      margin: 0; 
      background: linear-gradient(180deg, rgba(59, 130, 246, 0.02) 0%, transparent 100%);
    }
    .toc li { margin: 0; }
    .list-group-item { 
      background: transparent; 
      border-color: transparent; 
      padding: 0; 
      margin: 0.25rem 0.75rem; 
      border-radius: 0rem;
      transition: all 0.2s ease;
    }
    .list-group-item a { 
      color: #1f2937; 
      text-decoration: none; 
      display: flex; 
      flex-direction: column; 
      align-items: flex-start; 
      gap: 0.4rem; 
      border-left: 3px solid transparent; 
      padding: 0.85rem 1.25rem; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
      font-weight: 500; 
      border-radius: 0rem;
      font-size: 0.95rem;
      position: relative;
      overflow: hidden;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 100%);
      border: 1px solid rgba(0, 0, 0, 0.06);
      backdrop-filter: blur(10px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    .list-group-item a::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 0px 0px 0;
    }
    .list-group-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    .list-group-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
    }
    .list-group-item a:hover::before {
      transform: scaleY(1);
    }
    .list-group-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    .list-group-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-item a.active::before {
      transform: scaleY(1);
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      width: 5px;
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .list-group-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    /* Badge styling */
    .badge { font-size: 0.8rem; padding: 0.15rem 0.4rem; background: var(--accent-light); color: var(--accent); border: 1px solid var(--accent); font-weight: 600; border-radius: 0.25rem; font-style: normal; line-height: 1.2; opacity: 0.9; }
    .badge { background: var(--accent); color: white; border: none; font-size: 0.6rem; padding: 0.25rem 0.5rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; display: inline-block; margin-top: 0.5rem; margin-right: 0.35rem; }
    .list-group-item a:hover .badge { opacity: 1; background: var(--accent); color: white; }
    .list-group-item a.active .badge { background: rgba(255, 255, 255, 0.3); color: white; border-color: rgba(255, 255, 255, 0.6); font-weight: 600; opacity: 1; }
        
    /* Content */
    .content { width: 100%; max-width: 100%; margin: 0 auto; background: #ffffff; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08); }
    section { display: none !important; margin-bottom: 2rem; }
    section.active { display: block !important; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    h1 { font-size: 2rem; font-weight: 700; margin: 1rem 0 0.25rem 0; letter-spacing: -0.5px; color: var(--fg); display: block; border: none; }
    h2 { font-size: 1.5rem; font-weight: 600; margin: 1.5rem 0 0.75rem 0; color: var(--fg); border-bottom: 2px solid var(--accent-light); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; color: var(--accent); font-weight: 600; margin: 1rem 0 0.5rem 0; }
    h4 { font-size: 0.8rem; color: var(--fg); font-weight: 600; margin: 0.75rem 0 0.4rem 0; }
    p { margin: 1rem 0; line-height: 1.65; color: var(--fg); }
    ul, ol { margin: 1rem 0; padding-left: 2rem; }
    li { margin: 0.5rem 0; color: var(--fg); }
    
    code { background: var(--code-bg); border: 1px solid var(--border); padding: 0.2rem 0.5rem; font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', monospace; font-size: 0.9em; color: var(--accent); border-radius: 0.5rem; }
    pre { background: var(--code-bg); border: 0px solid var(--border); padding: 1rem; border-radius: 0.5rem; overflow: auto; box-shadow: var(--shadow-sm); margin: 1rem 0; }
    pre code { padding: 0; background: transparent; border: none; color: var(--fg); }
    
    .callout { border-left: 5px solid var(--accent); background: var(--accent-light); padding: 1rem 1.2rem; margin: 1.5rem 0; border-radius: 0.5rem; box-shadow: var(--shadow-sm); font-weight: 500; color: var(--fg); }
    
    /* Table styling */
    .table { color: var(--fg); }
    .table thead th { background: var(--accent-light); color: var(--accent); border-color: var(--border); font-weight: 600; }
    .table tbody td { border-color: var(--border); }
    .table-striped tbody tr:nth-of-type(odd) { background-color: rgba(0,0,0,0.02); }
    .table-striped tbody tr:hover { background-color: var(--accent-light); }
    
    /* Controls/Pagination */
    .controls { opacity: 0.5; position: fixed; bottom: 0.25rem; right: 1rem; width: auto; z-index: 1000; background: transparent; display: flex; align-items: center; justify-content: center; gap: 0rem; padding: 0; min-height: 40px; }
    @media (max-width: 991px) {
      .controls { bottom: 0.25rem; right: 1rem; }
      .menu-header { color: var(--focus); }
    }
    .controls:hover { opacity: 1; }
    
    .page-indicator { color: var(--accent); font-weight: 600; font-size: 0.875rem; }
    .btn-group .btn { margin: 0px 2px; padding: 0.2rem 0.5rem; background: var(--accent); color: white; border-color: var(--accent); font-size: 1rem; font-weight: bold; }
    .btn-group .btn:hover { background: var(--accent); }
    .btn-group .btn + .btn { margin-left: -1px; }
    
    /* Mobile/Offcanvas */
    .offcanvas { background: var(--bg) !important; }
    .offcanvas-header { border-bottom: 1px solid var(--border); }
    .offcanvas-title { color: var(--fg); font-weight: 600; }
    .btn-close { color: var(--fg); }
    
    /* Scrollbar */
    nav.sidebar::-webkit-scrollbar { width: 6px; }
    nav.sidebar::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.05); }
    nav.sidebar::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.2); border-radius: 0px; }
    nav.sidebar::-webkit-scrollbar-thumb:hover { background: rgba(0, 0, 0, 0.3); }
    
    /* Mermaid Diagrams */
    .mermaid {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 2rem;
      margin: 1.5rem 0;
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      position: relative;
    }
    .mermaid.rendered {
      min-height: auto;
    }
    .mermaid svg {
      max-width: 100%;
      height: auto;
      min-height: 300px;
      transition: transform 0.3s ease;
      transform-origin: center center;
    }
    .mermaid.zoomed {
      overflow: auto;
      cursor: grab;
    }
    .mermaid.zoomed:active {
      cursor: grabbing;
    }
    .mermaid svg text {
      font-size: 14px !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }
    
    /* Mermaid title styling */
    .mermaid svg text, .diagram-modal-content svg text {
      font-size: 1rem !important;
      font-weight: bold !important;
      fill: var(--fg) !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }

    .mermaid svg *
    {
        color: #333;
    }

    .mermaid[data-processed="true"] {
      min-height: auto;
    }
    
    .mermaid svg {
      max-width: 100%;
      height: auto;
      display: inline-block;
    }
    
    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }
    .mermaid:hover .zoom-controls {
      opacity: 1;
    }
    .zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }

    /* Modal for diagram zoom */
    .diagram-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .diagram-modal.active {
      display: flex;
    }
    .diagram-modal-content {
      position: relative;
      width: 100%;
      height: 100%;
      background: white;
      border-radius: 0;
      padding: 3rem 3rem 3rem 3rem;
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    .diagram-modal-content svg {
      max-width: 100%;
      height: auto;
    }
    .modal-close {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
      z-index: 10000;
    }
    .modal-close:hover {
      background: #dc2626;
      transform: scale(1.1);
    }
    .modal-zoom-controls {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      display: flex;
      gap: 0.5rem;
      z-index: 10000;
      padding: 0rem;
      border-radius: 0.4rem;
    }
    .modal-zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .modal-zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }
    
    /* Utilities */
    .search { height: 0; overflow: hidden; padding: 0 !important; }
    .search input { display: none; }
    .min-vh-100 { min-height: 100vh; }
    .skip-link { position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; }
    .skip-link:focus { position: static; width: auto; height: auto; padding: 0.4rem 0.6rem; background: var(--accent); color: white; border-radius: 0.4rem; }
    
    /* Override Bootstrap defaults for theme */
    a { color: var(--accent); }
    a:hover { color: var(--accent); text-decoration: underline; }
    
    /* Responsive - keep sidebar visible on desktop, offcanvas on mobile */
    @media (max-width: 991px) {
      nav.sidebar { display: none; }
      #main { width: 100%; }
      .row { --bs-gutter-x: 0; }
    }
    
    /* Layout - prevent unnecessary scrolling */
    html, body { height: 100%; margin: 0; }
    #appContainer { display: flex; flex-direction: column; height: calc(100vh - 50px); }
    #mainRow { flex: 1; overflow: hidden; display: flex; }
    nav.sidebar { overflow-y: auto; max-height: 100%; position: relative; padding-bottom: 0px; }
    #main { overflow: hidden; display: flex; flex-direction: column; height: 100%; -webkit-tap-highlight-color: transparent; outline: none; border: none; }
    #main:focus { outline: none; }
    .content { overflow-y: auto; flex: 1; width: 100%; min-height: 0; padding: 0rem 1.5rem 0rem 1.5rem; }
    
    /* Contact Info */
    .contact-info {
      font-weight: 400 !important;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      color: var(--accent-light);
      margin: 0;
      opacity: 0.5;
      white-space: nowrap;
      cursor: pointer;
    }
    .contact-info:hover {
      opacity: 0.9;
      text-decoration: none;
    }
    @media (max-width: 991px) {
      .navbar-brand {
        font-size: 1rem !important;
        flex: 1;
      }
      .contact-info {
        font-size: 0.7rem;
        padding: 0.25rem 0.5rem;
      }
    }
    @media (max-width: 576px) {
      .navbar-brand {
        font-size: 0.9rem !important;
      }
      .contact-info {
        font-size: 0.65rem;
        padding: 0.2rem 0.4rem;
      }
    }

    .list-style-none {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* JSON Syntax Highlighting */
    pre code.language-json {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-json .json-key {
      color: #0451a5;
      font-weight: 500;
    }

    pre code.language-json .json-string {
      color: #a31515;
    }

    pre code.language-json .json-number {
      color: #098658;
    }

    pre code.language-json .json-boolean {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-null {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-punctuation {
      color: #333;
    }

    /* SQL Syntax Highlighting */
    pre code.language-sql {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-sql .sql-keyword {
      color: #0000ff;
      font-weight: 600;
      text-transform: uppercase;
    }

    pre code.language-sql .sql-string {
      color: #a31515;
    }

    pre code.language-sql .sql-number {
      color: #098658;
    }

    pre code.language-sql .sql-comment {
      color: #008000;
      font-style: italic;
    }

    pre code.language-sql .sql-function {
      color: #795e26;
      font-weight: 500;
    }

    pre code.language-sql .sql-operator {
      color: #666;
      font-weight: 500;
    }

    /* Language Label for Code Blocks */
    pre[data-language]::before {
      content: attr(data-language);
      position: absolute;
      top: 8px;
      right: 12px;
      font-size: 0.75em;
      color: #6a737d;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: var(--bg);
      padding: 0.2rem 0.5rem;
      border-radius: 0.25rem;
      border: 1px solid var(--border);
    }

    /* Enhanced pre/code styling for syntax highlighted blocks */
    pre.syntax-highlighted {
      position: relative;
      background: var(--code-bg);
      border: 1px solid var(--border);
      padding: 1.5rem 1rem 1rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      box-shadow: var(--shadow-sm);
      margin: 1rem 0;
    }

    pre.syntax-highlighted code {
      background: transparent;
      padding: 0;
      border: none;
      color: var(--fg);
      font-size: 0.875rem;
      line-height: 1.6;
    }
  </style>
    <!-- Mermaid.js for diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <script>
        // Initialize Mermaid with proper configuration
        document.addEventListener('DOMContentLoaded', function() {

        mermaid.initialize({
            startOnLoad: false,
            theme: 'base',
            securityLevel: 'loose',
            logLevel: 'error',
            flowchart: {
            useMaxWidth: true,
            htmlLabels: true,
            curve: 'basis',
            },
            sequence: {
            useMaxWidth: false,
            htmlLabels: true,
            diagramMarginX: 50,
            diagramMarginY: 10
            }
        });
        
        // Render all diagrams
        renderMermaidDiagrams();
        });
        
        async function renderMermaidDiagrams() {
        const diagrams = document.querySelectorAll('.mermaid');
        
        for (let i = 0; i < diagrams.length; i++) {
            const diagram = diagrams[i];
            const code = diagram.textContent.trim();
            
            // Store original code
            if (!diagram.hasAttribute('data-original-code')) {
            diagram.setAttribute('data-original-code', code);
            }
            
            try {
            const { svg } = await mermaid.render('mermaid-diagram-' + i, code);
            diagram.innerHTML = svg;
            diagram.setAttribute('data-processed', 'true');
            
            // Add zoom controls
            addZoomControls(diagram);
            } catch (error) {
            console.error('Mermaid rendering error for diagram ' + i + ':', error);
            diagram.innerHTML = '<div style="color: red; padding: 1rem; border: 2px solid red; border-radius: 0.5rem;">Error rendering diagram: ' + error.message + '</div>';
            }
        }
        }
        
        // Add zoom controls to mermaid diagrams
        function addZoomControls(diagram) {
        const controls = document.createElement('div');
        controls.className = 'zoom-controls';
        controls.innerHTML = `
            <button class="zoom-btn" data-action="expand" title="Expand View">‚õ∂</button>
        `;
        
        diagram.style.position = 'relative';
        diagram.insertBefore(controls, diagram.firstChild);
        
        // Expand to modal
        controls.addEventListener('click', (e) => {
            const btn = e.target.closest('.zoom-btn');
            if (!btn) return;
            
            openDiagramModal(diagram);
        });
        }

        // Open diagram in modal
        function openDiagramModal(diagram) {
        // Create modal if it doesn't exist
        let modal = document.getElementById('diagram-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'diagram-modal';
            modal.className = 'diagram-modal';
            modal.innerHTML = `
            <button class="modal-close" id="modal-close">√ó</button>
            <div class="diagram-modal-content" id="modal-diagram-content"></div>
            <div class="modal-zoom-controls">
                <button class="modal-zoom-btn" data-action="zoom-in" title="Zoom In">+</button>
                <button class="modal-zoom-btn" data-action="zoom-out" title="Zoom Out">‚àí</button>
                <button class="modal-zoom-btn" data-action="reset" title="Reset Zoom">‚ü≤</button>
            </div>
            `;
            document.body.appendChild(modal);
            
            // Close modal handlers
            modal.querySelector('#modal-close').addEventListener('click', closeDiagramModal);
            modal.addEventListener('click', (e) => {
            if (e.target === modal) closeDiagramModal();
            });
            document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                closeDiagramModal();
            }
            });
            
            // Zoom controls in modal
            let scale = 1;
            let translateX = 0;
            let translateY = 0;
            
            modal.querySelector('.modal-zoom-controls').addEventListener('click', (e) => {
            const btn = e.target.closest('.modal-zoom-btn');
            if (!btn) return;
            
            const action = btn.dataset.action;
            const svg = modal.querySelector('svg');
            if (!svg) return;
            
            if (action === 'zoom-in') {
                scale = Math.min(scale + 0.1, 5);
            } else if (action === 'zoom-out') {
                scale = Math.max(scale - 0.1, 0.5);
            } else if (action === 'reset') {
                scale = 1;
                translateX = 0;
                translateY = 0;
            }
            
            svg.style.transform = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`;
            });
        }
        
        // Clone diagram content
        const svg = diagram.querySelector('svg');
        if (svg) {
            const content = modal.querySelector('#modal-diagram-content');
            content.innerHTML = '';
            const clonedSvg = svg.cloneNode(true);
            clonedSvg.style.transform = 'scale(1)';
            clonedSvg.style.maxWidth = '100%';
            clonedSvg.style.height = 'auto';
            content.appendChild(clonedSvg);
        }
        
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
        }

        function closeDiagramModal() {
        const modal = document.getElementById('diagram-modal');
        if (modal) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
        }
        
        // Re-render on theme change
        window.rerenderMermaid = async function() {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        
        mermaid.initialize({
            startOnLoad: false,
            theme: isDark ? 'base' : 'base',
            securityLevel: 'loose',
            flowchart: {
            useMaxWidth: true,
            htmlLabels: true,
            curve: 'basis',
            },
            sequence: {
            useMaxWidth: false,
            htmlLabels: true,
            diagramMarginX: 50,
            diagramMarginY: 10
            }
        });
        
        const diagrams = document.querySelectorAll('.mermaid[data-processed="true"]');
        for (let i = 0; i < diagrams.length; i++) {
            const diagram = diagrams[i];
            const code = diagram.getAttribute('data-original-code');
            
            if (code) {
            try {
                const { svg } = await mermaid.render('mermaid-diagram-rerender-' + i + '-' + Date.now(), code);
                diagram.innerHTML = svg;
            } catch (error) {
                console.error('Mermaid re-rendering error:', error);
            }
            }
        }
        };
    </script>
    </head>
    <body>
    <nav class="navbar navbar-expand-lg sticky-top" aria-label="Top bar">
        <div class="container-fluid d-flex align-items-center">
        <button class="navbar-toggler me-2" id="toggleSidebar" type="button" aria-label="Toggle sidebar">
            <span class="navbar-toggler-icon"></span>
        </button>
        <span class="navbar-brand mb-0 h1 me-auto"><svg xmlns="http://www.w3.org/2000/svg" width="18px" height="18px" viewBox="0 0 128 128" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M105.825 58.635c5.491 22.449-8.458 45.049-31.156 50.48-22.695 5.429-45.547-8.365-51.036-30.815-5.492-22.449 8.458-45.049 31.153-50.48l.078-.018c22.588-5.46 45.374 8.223 50.896 30.565l.065.268Z" fill="#59B3D8"/><path fill-rule="evenodd" clip-rule="evenodd" d="M58.747 85.194c-.013-6.137-5.055-11.1-11.259-11.085h-1.701c1.442-5.932-2.248-11.895-8.246-13.322a11.182 11.182 0 0 0-2.703-.306H23.162c-2.525 12.851 1.246 26.127 10.174 35.796h14.149c6.205.015 11.247-4.948 11.262-11.083ZM72.69 39.233c0 .649.085 1.296.255 1.925h-4.861c-6.445 0-11.667 5.168-11.667 11.543 0 6.372 5.222 11.54 11.667 11.54h38.645c-1.258-13.787-9.486-26.01-21.862-32.477h-4.605c-4.177-.002-7.562 3.339-7.572 7.469Zm34.043 33.587H83.679c-5.259-.013-9.531 4.187-9.552 9.385a9.241 9.241 0 0 0 1.148 4.471c-5.003 1.546-7.792 6.814-6.228 11.765 1.242 3.934 4.938 6.607 9.106 6.589h6.427c12.314-6.454 20.607-18.51 22.153-32.21Z" fill="#B6DEEC"/><path fill-rule="evenodd" clip-rule="evenodd" d="M17.382 40.624a1.286 1.286 0 0 1-1.3-1.275v-.003c-.021-8.064-6.637-14.587-14.79-14.579A1.286 1.286 0 0 1 0 23.489c0-.703.579-1.275 1.292-1.275 8.143.007 14.756-6.503 14.79-14.554a1.29 1.29 0 0 1 1.356-1.227c.672.028 1.21.56 1.241 1.227.021 8.061 6.639 14.584 14.792 14.577.713 0 1.292.572 1.292 1.277 0 .706-.579 1.279-1.292 1.279-8.148-.011-14.766 6.507-14.792 14.566-.01.7-.589 1.265-1.297 1.265Z" fill="#B7D332"/><path fill-rule="evenodd" clip-rule="evenodd" d="M108.6 122.793a.764.764 0 0 1-.768-.759c-.018-4.821-3.98-8.719-8.854-8.709a.762.762 0 0 1-.77-.756c0-.419.342-.759.765-.759h.005c4.872.002 8.826-3.893 8.844-8.711a.77.77 0 0 1 .778-.767.77.77 0 0 1 .775.767c.018 4.818 3.972 8.713 8.843 8.711a.761.761 0 0 1 .77.756.759.759 0 0 1-.765.759h-.005c-4.871-.002-8.828 3.893-8.843 8.714a.764.764 0 0 1-.773.754h-.002Z" fill="#0072C5"/><path fill-rule="evenodd" clip-rule="evenodd" d="M126.317 30.84c-4.035-6.539-14.175-8.049-29.306-4.384a121.688 121.688 0 0 0-13.893 4.384 42.829 42.829 0 0 1 8.187 5.173c2.574-.836 5.101-1.59 7.512-2.173a53.33 53.33 0 0 1 12.335-1.727c4.957 0 7.691 1.211 8.606 2.686 1.496 2.423.119 8.816-8.681 18.871-1.566 1.789-3.326 3.601-5.179 5.423a175.936 175.936 0 0 1-31.843 24.149 176.032 176.032 0 0 1-36.329 17.105c-15.317 4.936-25.773 4.836-28.119 1.048-2.342-3.788 2.344-13.048 13.776-24.29a41.005 41.005 0 0 1-.938-9.735c-18.2 16.271-24.09 30.365-19.387 37.981 2.463 3.985 7.844 6.229 15.705 6.229a80.772 80.772 0 0 0 27.183-5.932 194.648 194.648 0 0 0 32.11-15.926 193.405 193.405 0 0 0 28.884-21.148 118.565 118.565 0 0 0 9.947-9.941c10.207-11.655 13.466-21.268 9.43-27.793Z" fill="#000"/></svg>
            Azure Cosmos DB - In a Nutshell</span>
        <span class="contact-info mb-0">ü§ù Curated by Murthy Vepa</span>
        </div>      
    </nav>

    <div id="appContainer">
        <div class="row g-0" id="mainRow">
        <nav class="col-lg-3 border-end sidebar" id="sidebar" aria-label="Table of contents">
            <div class="menu-header py-2">Contents</div>
            <ul class="list-group list-group-flush toc" id="toc"></ul>
        </nav>

        <main id="main" class="col-lg-9 d-flex flex-column" tabindex="-1">
            <div class="content" id="content">
            <section id="cosmosdb-concepts" role="article">
                <h1>Core Concepts and Architecture</h1>
                <span class="badge">intro</span>
                <span class="badge">overview</span>
                <span class="badge">concepts</span>

                <h2>Table of Contents</h2>
                <ol>
                    <li><a href="#introduction">Introduction</a></li>
                    <li><a href="#what-is-azure-cosmos-db">What is Azure Cosmos DB?</a></li>
                    <li><a href="#multi-model-architecture">Multi-Model Architecture</a></li>
                    <li><a href="#global-distribution">Global Distribution</a></li>
                    <li><a href="#partitioning-strategy">Partitioning Strategy</a></li>
                    <li><a href="#consistency-levels">Consistency Levels</a></li>
                    <li><a href="#request-units-rus">Request Units (RUs)</a></li>
                    <li><a href="#indexing-strategy">Indexing Strategy</a></li>
                    <li><a href="#resource-model">Resource Model</a></li>
                    <li><a href="#use-cases">Use Cases</a></li>
                    <li><a href="#summary">Summary</a></li>
                </ol>

                <h2 id="introduction">1. Introduction</h2>

                <p>Azure Cosmos DB is Microsoft's globally distributed, multi-model database service designed for mission-critical applications that require low latency, high availability, and elastic scalability at a global scale.</p>

                <h2 id="what-is-azure-cosmos-db">2. What is Azure Cosmos DB?</h2>
                <p>Azure Cosmos DB is a fully managed NoSQL and relational database service that provides:</p>

                <ul>
                    <li>üåç <strong>Global Distribution</strong>: Replicate your data across multiple Azure regions worldwide</li>
                    <li>‚ö° <strong>Low Latency</strong>: Single-digit millisecond response times at the 99th percentile</li>
                    <li>‚úì <strong>High Availability</strong>: 99.999% availability SLA</li>
                    <li>üìä <strong>Multi-Model Support</strong>: Work with multiple data models using a single database service</li>
                    <li>üìà <strong>Elastic Scalability</strong>: Scale throughput and storage independently</li>
                    <li>üîí <strong>Enterprise Security</strong>: Built-in security and compliance features</li>
                </ul>

                <h2 id="multi-model-architecture">3. Multi-Model Architecture</h2>

                <p>One of Cosmos DB's most powerful features is its support for multiple data models and APIs, all backed by the same underlying distributed database engine.</p>

                <h3>Supported APIs</h3>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI', 'fontSize':12, 'nodeSpacing': 200, 'rackSpacing': 100}}}%%
                flowchart TD
                    CosmosDB["Azure Cosmos DB 
                Unified Database Engine"]

                    CosmosDB --> NoSQL["NoSQL API 
                (Core SQL)"]
                    CosmosDB --> MongoDB["MongoDB API"]
                    CosmosDB --> Cassandra["Cassandra API"]
                    CosmosDB --> Gremlin["Gremlin API 
                (Graph)"]
                    CosmosDB --> Table["Table API"]
                    CosmosDB --> PostgreSQL["PostgreSQL API"]
                    
                    NoSQL --> UseCase1["Document Store 
                JSON data"]
                    MongoDB --> UseCase2["MongoDB 
                Compatibility"]
                    Cassandra --> UseCase3["Wide Column 
                Store"]
                    Gremlin --> UseCase4["Graph 
                Relationships"]
                    Table --> UseCase5["Key-Value 
                Store"]
                    PostgreSQL --> UseCase6["Relational 
                PostgreSQL"]
                    
                    style CosmosDB fill:#FFF4DD,stroke:#EEDDBB,stroke-width:2px,color:#fff
                    style NoSQL fill:#50E6FF,stroke:#0078D4,color:#000
                    style MongoDB fill:#50E6FF,stroke:#0078D4,color:#000
                    style Cassandra fill:#50E6FF,stroke:#0078D4,color:#000
                    style Gremlin fill:#50E6FF,stroke:#0078D4,color:#000
                    style Table fill:#50E6FF,stroke:#0078D4,color:#000
                    style PostgreSQL fill:#50E6FF,stroke:#0078D4,color:#000
                </div>

                <h3>API Characteristics</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>API</th>
                            <th>Best For</th>
                            <th>Data Model</th>
                            <th>Query Language</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>NoSQL (SQL API)</strong></td>
                            <td>General-purpose, JSON documents</td>
                            <td>Document</td>
                            <td>SQL-like queries</td>
                        </tr>
                        <tr>
                            <td><strong>MongoDB</strong></td>
                            <td>MongoDB migrations</td>
                            <td>Document</td>
                            <td>MongoDB Query Language</td>
                        </tr>
                        <tr>
                            <td><strong>Cassandra</strong></td>
                            <td>Wide-column data</td>
                            <td>Column-family</td>
                            <td>CQL (Cassandra Query Language)</td>
                        </tr>
                        <tr>
                            <td><strong>Gremlin</strong></td>
                            <td>Graph relationships</td>
                            <td>Graph</td>
                            <td>Gremlin traversal language</td>
                        </tr>
                        <tr>
                            <td><strong>Table</strong></td>
                            <td>Key-value operations</td>
                            <td>Key-Value</td>
                            <td>OData queries</td>
                        </tr>
                        <tr>
                            <td><strong>PostgreSQL</strong></td>
                            <td>Relational data</td>
                            <td>Relational</td>
                            <td>SQL (PostgreSQL dialect)</td>
                        </tr>
                    </tbody>
                </table>

                <h2 id="global-distribution">4. Global Distribution</h2>

                <p>Azure Cosmos DB provides turnkey global distribution, allowing you to replicate your data to any Azure region with a single click.</p>

                <h3>Architecture</h3>

                <div class="mermaid">
                %%{init: {'theme':'default', 'themeVariables': {'fontFamily':'Segoe UI'}}}%%
                flowchart TB

                    subgraph "Primary Region: East US"
                        Primary["Primary Database 
                Read/Write"]
                    end
                    
                    subgraph "Secondary Region: West Europe"
                        Secondary1["Replica 
                Read/Write*"]
                    end
                    
                    subgraph "Secondary Region: Southeast Asia"
                        Secondary2["Replica 
                Read/Write*"]
                    end
                    
                    subgraph "Secondary Region: Australia East"
                        Secondary3["Replica 
                Read/Write*"]
                    end
                    
                    Primary <--> |"Automatic 
                Replication"| Secondary1
                    Primary <--> |"Automatic 
                Replication"| Secondary2
                    Primary <--> |"Automatic 
                Replication"| Secondary3
                    Secondary1 <--> Secondary2
                    Secondary2 <--> Secondary3
                    
                    Client1["Client Application 
                USA"] --> Primary
                    Client2["Client Application 
                Europe"] --> Secondary1
                    Client3["Client Application 
                Asia"] --> Secondary2
                    Client4["Client Application 
                Australia"] --> Secondary3
                    
                    style Primary fill:#0078D4,stroke:#005A9E,color:#fff
                    style Secondary1 fill:#50E6FF,stroke:#0078D4,color:#000
                    style Secondary2 fill:#50E6FF,stroke:#0078D4,color:#000
                    style Secondary3 fill:#50E6FF,stroke:#0078D4,color:#000
                </div>

                <h3>Multi-Region Write Capabilities</h3>

                <p>With <strong>multi-region writes</strong> enabled, every region acts as both a read and write region, providing:</p>

                <ul>
                    <li><strong>Low write latency</strong> from any region</li>
                    <li><strong>Automatic conflict resolution</strong></li>
                    <li><strong>Higher availability</strong> (99.999% SLA)</li>
                </ul>

                <h2 id="partitioning-strategy">5. Partitioning Strategy</h2>

                <p>Partitioning is fundamental to Cosmos DB's ability to scale horizontally. Understanding partitioning is crucial for optimal performance.</p>

                <h3>Logical Partitioning</h3>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI'}}}%%
                block-beta
                columns 3
                
                space Container["Container
                (Collection)"] space
                
                space down1<["Partition Key:
                userId"]>(down) space
                
                P1["Partition 1
                userId: user-001 to user-333"]
                P2["Partition 2
                userId: user-334 to user-666"]
                P3["Partition 3
                userId: user-667 to user-999"]
                
                I1["Items
                Max 20GB"]
                I2["Items
                Max 20GB"]
                I3["Items
                Max 20GB"]
                
                style Container fill:#0078D4,stroke:#005A9E,color:#fff
                style P1 fill:#50E6FF,stroke:#0078D4,color:#000
                style P2 fill:#50E6FF,stroke:#0078D4,color:#000
                style P3 fill:#50E6FF,stroke:#0078D4,color:#000
                style I1 fill:#E6F7FF,stroke:#50E6FF,color:#000
                style I2 fill:#E6F7FF,stroke:#50E6FF,color:#000
                style I3 fill:#E6F7FF,stroke:#50E6FF,color:#000
                </div>

                <h3>Hierarchical Partition Keys (HPK)</h3>

                <p>Hierarchical Partition Keys allow you to overcome the 20 GB limit and provide better query flexibility.</p>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI'}}}%%
                flowchart TB
                    subgraph Traditional["Traditional Single Partition Key"]
                        T1["tenantId: tenant-001
                Max 20GB
                ‚ùå Limited"]
                    end
                    
                    subgraph Hierarchical["Hierarchical Partition Key"]
                        H1["Level 1: tenantId"]
                        H2["Level 2: userId"]
                        H3["Level 3: sessionId"]
                        Note["‚úì Overcomes 20GB limit
                ‚úì Better query targeting
                ‚úì Flexible distribution"]
                        
                        H1 --> H2 --> H3
                    end
                    
                    style T1 fill:#FFB6C1,stroke:#FF69B4,color:#000
                    style H1 fill:#50E6FF,stroke:#0078D4,color:#000
                    style H2 fill:#7FE6FF,stroke:#0078D4,color:#000
                    style H3 fill:#AAEEFF,stroke:#0078D4,color:#000
                    style Note fill:#D4FFD4,stroke:#00AA00,color:#000
                </div>

                <h3>Partition Key Selection Guidelines</h3>

                <p><strong>Good Partition Keys:</strong></p>
                <ul>
                    <li>‚úÖ High cardinality (many unique values)</li>
                    <li>‚úÖ Evenly distributed data</li>
                    <li>‚úÖ Aligns with query patterns</li>
                    <li>‚úÖ Examples: <code>userId</code>, <code>tenantId</code>, <code>deviceId</code></li>
                </ul>

                <p><strong>Poor Partition Keys:</strong></p>
                <ul>
                    <li>‚ùå Low cardinality</li>
                    <li>‚ùå Creates hot partitions</li>
                    <li>‚ùå Examples: <code>status</code>, <code>country</code>, <code>boolean</code> fields</li>
                </ul>

                <h2 id="consistency-levels">6. Consistency Levels</h2>

                <p>Cosmos DB offers five consistency levels, allowing you to balance between consistency, availability, and latency.</p>

                <h3>Consistency Spectrum</h3>

                <div class="mermaid">
                %%{init: {'theme':'default', 'themeVariables': {'fontFamily':'Segoe UI'}}}%%
                flowchart LR
                    Strong["Strong
                Consistency"]
                    Bounded["Bounded
                Staleness"]
                    Session["Session
                Consistency"]
                    Consistent["Consistent
                Prefix"]
                    Eventual["Eventual
                Consistency"]
                    
                    Strong --> Bounded
                    Bounded --> Session
                    Session --> Consistent
                    Consistent --> Eventual
                    
                    Strong -.->|"Highest"| SC1["Consistency ‚¨ÜÔ∏è"]
                    Eventual -.->|"Lowest"| SC2["Latency ‚¨áÔ∏è
                Throughput ‚¨ÜÔ∏è"]
                    
                    style Strong fill:#FF6B6B,stroke:#CC0000,color:#fff
                    style Bounded fill:#FFA07A,stroke:#FF6347,color:#000
                    style Session fill:#FFD700,stroke:#FFA500,color:#000
                    style Consistent fill:#90EE90,stroke:#32CD32,color:#000
                    style Eventual fill:#87CEEB,stroke:#4682B4,color:#000
                </div>

                <h3>Consistency Level Comparison</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Level</th>
                            <th>Guarantee</th>
                            <th>Use Case</th>
                            <th>Performance</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Strong</strong></td>
                            <td>Linearizability</td>
                            <td>Financial transactions, inventory</td>
                            <td>Highest latency</td>
                        </tr>
                        <tr>
                            <td><strong>Bounded Staleness</strong></td>
                            <td>Consistent within bounds</td>
                            <td>Live scoreboards</td>
                            <td>High latency</td>
                        </tr>
                        <tr>
                            <td><strong>Session</strong></td>
                            <td>Consistent within session</td>
                            <td>User profiles, shopping carts</td>
                            <td>Balanced</td>
                        </tr>
                        <tr>
                            <td><strong>Consistent Prefix</strong></td>
                            <td>Reads never see out-of-order writes</td>
                            <td>Social feeds</td>
                            <td>Lower latency</td>
                        </tr>
                        <tr>
                            <td><strong>Eventual</strong></td>
                            <td>Eventually consistent</td>
                            <td>Analytics, telemetry</td>
                            <td>Lowest latency</td>
                        </tr>
                    </tbody>
                </table>

                <h2 id="request-units-rus">7. Request Units (RUs)</h2>

                <p>Request Units (RUs) are Azure Cosmos DB's currency for measuring the cost of database operations. Understanding RUs is crucial for capacity planning, cost optimization, and performance tuning.</p>

                <h3>What is a Request Unit?</h3>

                <p>A <strong>Request Unit (RU)</strong> represents the computational resources (CPU, memory, IOPS) required to perform a database operation.</p>

                <b>1 RU is the cost of reading a 1 KB item by its ID and partition key.</b>
                
                1 RU can be thought of as a blend of: CPU time, memory usage, and I/O operations.

                <div class="callout">
                    <p><strong>‚ö†Ô∏è Important: RU Cost Variability</strong></p>
                    <p>The actual RU cost of operations varies significantly based on multiple factors:</p>
                    <ul>
                        <li>Item size (larger items = more RUs)</li>
                        <li>Indexing policy (more indexes = higher write cost)</li>
                        <li>Query complexity (joins, aggregations, ORDER BY)</li>
                        <li>Consistency level (Strong consistency = higher cost)</li>
                        <li>Number of properties and nesting depth</li>
                        <li>Geo-replication configuration</li>
                    </ul>
                    <p>Always <strong>test and measure</strong> RU consumption for your specific workload and data model. Use Azure Portal metrics or SDK diagnostics to monitor actual costs.</p>
                </div>

                <h3>Factors Affecting RU Consumption</h3>

                <div class="mermaid">
                %%{init: {'theme':'default', 'themeVariables': {'fontFamily':'Segoe UI'}}}%%
                block-beta
                columns 3
                
                block:ItemSize:1
                    columns 1
                    ISTitle["üì¶ Item Size"]
                    IS1["Larger items = More RUs"]
                    IS2["1 KB baseline"]
                    IS3["10 KB = ~10x cost"]
                end
                
                block:IndexPolicy:1
                    columns 1
                    IPTitle["üìá Indexing Policy"]
                    IP1["More indexes = Higher write cost"]
                    IP2["Selective indexing reduces cost"]
                    IP3["No indexing = Lowest write cost"]
                end
                
                block:QueryComplexity:1
                    columns 1
                    QCTitle["üîç Query Complexity"]
                    QC1["Filters, joins, aggregations"]
                    QC2["ORDER BY operations"]
                    QC3["Cross-partition queries"]
                end
                
                block:Consistency:1
                    columns 1
                    ConTitle["‚öñÔ∏è Consistency Level"]
                    Con1["Strong = Higher RU cost"]
                    Con2["Eventual = Lower RU cost"]
                    Con3["Applies to reads"]
                end
                
                block:Replication:1
                    columns 1
                    RepTitle["üåç Geo-Replication"]
                    Rep1["Multi-region writes"]
                    Rep2["Number of regions"]
                    Rep3["Replication overhead"]
                end
                
                block:ItemProps:1
                    columns 1
                    PropTitle["üè∑Ô∏è Item Properties"]
                    Prop1["Number of properties"]
                    Prop2["Property depth (nesting)"]
                    Prop3["Data types complexity"]
                end
                
                style ISTitle fill:#0078D4,stroke:#005A9E,color:#fff
                style IPTitle fill:#0078D4,stroke:#005A9E,color:#fff
                style QCTitle fill:#0078D4,stroke:#005A9E,color:#fff
                style ConTitle fill:#0078D4,stroke:#005A9E,color:#fff
                style RepTitle fill:#0078D4,stroke:#005A9E,color:#fff
                style PropTitle fill:#0078D4,stroke:#005A9E,color:#fff
                </div>

                <h3>Throughput Provisioning Models</h3>

                <p>Azure Cosmos DB offers three throughput provisioning models:</p>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI'}}}%%
                flowchart TD
                    Start{{"**Choose Throughput
                Model**"}}
                    
                    Start --> Manual["**Manual/Provisioned
                Throughput**"]
                    Start --> Autoscale["**Autoscale
                Throughput**"]
                    Start --> Serverless["**Serverless**"]
                    
                    Manual --> ManualDetails["Fixed RU/s capacity 
                    Predictable costs 
                    Best for steady workloads 
                    Min: 400 RU/s"]
                    
                    Autoscale --> AutoDetails["Scales 0-10x max RU/s
                    Pay for actual usage
                    Best for variable workloads
                    Min: 1,000 RU/s max"]
                    
                    Serverless --> ServerDetails["Pay per request 
                    No provisioning needed
                    Best for dev/test 
                    Max: 5,000 RU/s"]
                    
                    style Start fill:#FFD700,stroke:#FFA500,color:#000
                    style Manual fill:#87CEEB,stroke:#4682B4,color:#000
                    style Autoscale fill:#90EE90,stroke:#32CD32,color:#000
                    style Serverless fill:#DDA0DD,stroke:#9370DB,color:#000
                    style ManualDetails fill:#E6F7FF,stroke:#87CEEB,color:#000
                    style AutoDetails fill:#D4FFD4,stroke:#90EE90,color:#000
                    style ServerDetails fill:#F0E6FF,stroke:#DDA0DD,color:#000
                </div>

                <h3>Throughput Model Comparison</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Manual</th>
                            <th>Autoscale</th>
                            <th>Serverless</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Min RU/s</strong></td>
                            <td>400</td>
                            <td>1,000 max</td>
                            <td>None</td>
                        </tr>
                        <tr>
                            <td><strong>Max RU/s</strong></td>
                            <td>Unlimited</td>
                            <td>Unlimited</td>
                            <td>5,000</td>
                        </tr>
                        <tr>
                            <td><strong>Scaling</strong></td>
                            <td>Manual</td>
                            <td>Automatic</td>
                            <td>Automatic</td>
                        </tr>
                        <tr>
                            <td><strong>Cost Model</strong></td>
                            <td>Fixed hourly</td>
                            <td>Hourly based on usage</td>
                            <td>Per request</td>
                        </tr>
                        <tr>
                            <td><strong>Best For</strong></td>
                            <td>Steady workloads</td>
                            <td>Variable workloads</td>
                            <td>Dev/Test, Intermittent</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Shared vs Dedicated Throughput</h3>

                <p>You can provision throughput at two levels: <strong>Database-level</strong> (shared) or <strong>Container-level</strong> (dedicated).</p>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th style="width: 50%;">Database-Level (Shared)</th>
                            <th style="width: 50%;">Container-Level (Dedicated)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <strong>Example Configuration:</strong><br>
                                Database: 10,000 RU/s<br>
                                ‚îî‚îÄ‚îÄ Container 1 (shares from pool)<br>
                                ‚îî‚îÄ‚îÄ Container 2 (shares from pool)<br>
                                ‚îî‚îÄ‚îÄ Container 3 (shares from pool)
                            </td>
                            <td>
                                <strong>Example Configuration:</strong><br>
                                Container A: 5,000 RU/s (dedicated)<br>
                                Container B: 3,000 RU/s (dedicated)<br>
                                Container C: 2,000 RU/s (dedicated)
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Pros:</strong><br>
                                ‚úì Cost-effective for many containers<br>
                                ‚úì Dynamic allocation across containers<br>
                                ‚úì Lower minimum RU requirements
                            </td>
                            <td>
                                <strong>Pros:</strong><br>
                                ‚úì Guaranteed throughput per container<br>
                                ‚úì Predictable performance<br>
                                ‚úì No resource contention
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Cons:</strong><br>
                                ‚ùå No guaranteed minimum per container<br>
                                ‚ùå Potential resource contention<br>
                                ‚ùå Limited to 25 containers max
                            </td>
                            <td>
                                <strong>Cons:</strong><br>
                                ‚ùå Higher cost (each container has minimum)<br>
                                ‚ùå Less flexibility<br>
                                ‚ùå Over-provisioning risk
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Best For:</strong> Dev/test, microservices with many small containers</td>
                            <td><strong>Best For:</strong> Production workloads with critical SLAs</td>
                        </tr>
                    </tbody>
                </table>

                <h2 id="indexing-strategy">8. Indexing Strategy</h2>

                <p>Azure Cosmos DB automatically indexes all properties in your documents by default, enabling fast queries without requiring schema or index management.</p>

                <h3>How Indexing Works</h3>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI'}, 'flowchart': {'nodeSpacing': 50, 'rankSpacing': 80}}}%%
                flowchart TB
                    Start["üìÑ Document Inserted/Updated"]
                    
                    subgraph Indexing["**Automatic Indexing Process**"]
                        direction TB
                        Extract["üîç Extract All Paths
                        /name, /price, /category,
                        /address/city, etc."]
                        
                        Build["üèóÔ∏è Build Index Entries
                        For each path + value"]
                        
                        Store["üíæ Store in Index
                        B-Tree structure"]
                    end
                    
                    Result["‚ö° Query Execution
                    Fast lookups via index
                    No full scans needed"]
                    
                    Start --> Extract
                    Extract --> Build
                    Build --> Store
                    Store --> Result
                    
                    Note["üìå All properties indexed by default
                    Customize via indexing policy
                    Exclude paths to reduce write RU cost"]
                    
                    style Start fill:#87CEEB,stroke:#4682B4,color:#000
                    style Extract fill:#FFE6CC,stroke:#FFA500,color:#000
                    style Build fill:#FFF4CC,stroke:#FFD700,color:#000
                    style Store fill:#E6F7FF,stroke:#50E6FF,color:#000
                    style Result fill:#D4FFD4,stroke:#32CD32,color:#000
                    style Note fill:#FFE6E6,stroke:#FF6B6B,color:#000
                    style Indexing fill:#F0F0F0,stroke:#999,stroke-width:2px
                </div>

                <h3>Indexing Modes</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Mode</th>
                            <th>Description</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Consistent (Default)</strong></td>
                            <td>Index updated synchronously with writes</td>
                            <td>Production workloads requiring up-to-date queries</td>
                        </tr>
                        <tr>
                            <td><strong>No Indexing</strong></td>
                            <td>No indexes maintained</td>
                            <td>Write-only scenarios, lowest write cost</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Index Types</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Index Type</th>
                            <th>Use Case</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Range</strong></td>
                            <td>Equality, range queries, ORDER BY</td>
                            <td><code>WHERE c.price > 100</code></td>
                        </tr>
                        <tr>
                            <td><strong>Spatial</strong></td>
                            <td>Geospatial queries</td>
                            <td><code>ST_DISTANCE</code>, <code>ST_WITHIN</code></td>
                        </tr>
                        <tr>
                            <td><strong>Composite</strong></td>
                            <td>Multi-property ORDER BY, complex filters</td>
                            <td><code>ORDER BY c.category, c.price</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Indexing Best Practices</h3>

                <p><strong>‚úÖ DO:</strong></p>
                <ul>
                    <li>Index frequently queried properties</li>
                    <li>Use composite indexes for multi-property sorts</li>
                    <li>Exclude large unused properties</li>
                    <li>Monitor index storage size</li>
                </ul>

                <p><strong>‚ùå DON'T:</strong></p>
                <ul>
                    <li>Index everything unnecessarily</li>
                    <li>Forget to exclude large arrays/objects</li>
                    <li>Ignore RU cost of writes</li>
                    <li>Skip composite indexes for ORDER BY</li>
                </ul>

                <h2 id="resource-model">9. Resource Model</h2>

                <p>Understanding Cosmos DB's resource hierarchy is essential for effective database design.</p>

                <h3>Resource Hierarchy</h3>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI'}}}%%
                flowchart TD

                    Account["Azure Cosmos DB Account
                Global endpoint"]
                    
                    Account --> DB1["Database 1"]
                    Account --> DB2["Database 2"]
                    
                    DB1 --> C1["Container 1
                (Collection)"]
                    DB1 --> C2["Container 2"]
                    
                    DB2 --> C3["Container 3"]
                    
                    C1 --> I1["Item 1
                (Document)"]
                    C1 --> I2["Item 2"]
                    C1 --> I3["Item 3"]
                    
                    C1 --> SP["Stored
                Procedures"]
                    C1 --> TR["Triggers"]
                    C1 --> UDF["User Defined
                Functions"]
                    
                    style Account fill:#0078D4,stroke:#005A9E,stroke-width:4px,color:#fff
                    style DB1 fill:#50E6FF,stroke:#0078D4,stroke-width:2px,color:#000
                    style DB2 fill:#50E6FF,stroke:#0078D4,stroke-width:2px,color:#000
                    style C1 fill:#7FE6FF,stroke:#0078D4,color:#000
                    style C2 fill:#7FE6FF,stroke:#0078D4,color:#000
                    style C3 fill:#7FE6FF,stroke:#0078D4,color:#000
                    style I1 fill:#E6F7FF,stroke:#50E6FF,color:#000
                    style I2 fill:#E6F7FF,stroke:#50E6FF,color:#000
                    style I3 fill:#E6F7FF,stroke:#50E6FF,color:#000
                </div>

                <h3>Resource Characteristics</h3>

                <ul>
                    <li><strong>Account</strong>: Global unique endpoint, can have multiple databases</li>
                    <li><strong>Database</strong>: Logical namespace for containers</li>
                    <li><strong>Container</strong>: Billable unit, has dedicated throughput (RU/s)</li>
                    <li><strong>Item</strong>: Individual document/record (max 2 MB)</li>
                </ul>

                <h2 id="use-cases">10. Use Cases</h2>

                <p>Azure Cosmos DB excels in specific scenarios where global distribution, low latency, and high availability are critical.</p>

                <h3>Ideal Use Cases by Category</h3>

                <p><strong>ü§ñ AI/Chat Applications:</strong></p>
                <ul>
                    <li>Chat History and conversation logging</li>
                    <li>User Context and memory management</li>
                    <li>Vector Search for semantic retrieval</li>
                    <li>RAG (Retrieval-Augmented Generation) patterns</li>
                </ul>

                <p><strong>üåê Web Applications:</strong></p>
                <ul>
                    <li>User Profiles and personalization</li>
                    <li>Shopping Carts and session state</li>
                    <li>Product Catalogs and inventory</li>
                    <li>Real-time Recommendations</li>
                </ul>

                <p><strong>üì° IoT Scenarios:</strong></p>
                <ul>
                    <li>Device Twins and metadata</li>
                    <li>Telemetry Data collection</li>
                    <li>Predictive Maintenance workflows</li>
                    <li>State Management hierarchies</li>
                </ul>

                <h3>API-Specific Use Cases</h3>

                <h4>NoSQL (SQL API) - General Purpose</h4>
                <p><strong>Best for:</strong> Document-based applications with flexible schemas and JSON data</p>
                <ul>
                    <li>Multi-user AI assistants with isolated context</li>
                    <li>Multi-tenant SaaS applications</li>
                    <li>Event sourcing and audit logs</li>
                </ul>

                <h4>MongoDB API</h4>
                <p><strong>Best for:</strong> Migrating existing MongoDB applications</p>
                <ul>
                    <li>MongoDB lift-and-shift migrations</li>
                    <li>Content management systems</li>
                </ul>

                <h4>Cassandra API</h4>
                <p><strong>Best for:</strong> Wide-column data and time-series workloads</p>
                <ul>
                    <li>IoT telemetry and time-series data</li>
                    <li>High-volume write scenarios</li>
                </ul>

                <h4>Gremlin API (Graph)</h4>
                <p><strong>Best for:</strong> Relationship-heavy data</p>
                <ul>
                    <li>Social networks and recommendations</li>
                    <li>Fraud detection patterns</li>
                </ul>

                <h4>Table API</h4>
                <p><strong>Best for:</strong> Simple key-value operations</p>
                <ul>
                    <li>Azure Table Storage migrations</li>
                    <li>Configuration storage</li>
                </ul>

                <h4>PostgreSQL API</h4>
                <p><strong>Best for:</strong> Relational workloads with global distribution needs</p>
                <ul>
                    <li>PostgreSQL database migrations</li>
                    <li>Traditional RDBMS workloads</li>
                </ul>

                <h3>When NOT to Use Cosmos DB</h3>

                <p><strong>Not ideal for:</strong></p>
                <ul>
                    <li>‚ùå Complex JOIN-heavy queries across documents</li>
                    <li>‚ùå Heavy aggregation workloads (use Azure Synapse)</li>
                    <li>‚ùå Large batch processing jobs</li>
                    <li>‚ùå OLAP and data warehousing</li>
                </ul>

                <h2 id="summary">11. Summary</h2>

                <p>Azure Cosmos DB is a powerful, globally distributed database service that excels in scenarios requiring:</p>

                <ul>
                    <li>‚úÖ <strong>Global scale</strong> with multi-region replication</li>
                    <li>‚úÖ <strong>Low latency</strong> (&lt; 10ms) at the 99th percentile</li>
                    <li>‚úÖ <strong>High availability</strong> with 99.999% SLA</li>
                    <li>‚úÖ <strong>Flexible data models</strong> with multiple API support</li>
                    <li>‚úÖ <strong>Elastic scalability</strong> for throughput and storage</li>
                </ul>

                <div class="callout">
                    <p><strong>Key Takeaways:</strong></p>
                    <ol>
                        <li>Choose the right API for your workload</li>
                        <li>Design partition keys carefully for optimal performance</li>
                        <li>Select appropriate consistency levels based on requirements</li>
                        <li>Follow SDK best practices for reliability</li>
                        <li>Use development tools (emulator, VS Code extension) effectively</li>
                        <li>Monitor and optimize costs regularly</li>
                    </ol>
                </div>

            </section>

            <section id="cosmosdb-data-modelling" role="article">
            <h1>Data Modelling and Partitioning</h1>
            <span class="badge">modeling</span>
            <span class="badge">partition-keys</span>
            <span class="badge">design</span>

            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#dm-core-concepts">Core Concepts</a></li>
                <li><a href="#dm-partitioning-strategy">Partitioning Strategy</a></li>
                <li><a href="#dm-data-modelling-approaches">Data Modelling Approaches</a></li>
                <li><a href="#dm-best-practices">Best Practices</a></li>
                <li><a href="#dm-dos-and-donts">Do's and Don'ts</a></li>
                <li><a href="#dm-common-patterns">Common Patterns</a></li>
                <li><a href="#dm-summary">Summary</a></li>
            </ol>

            <h2 id="dm-core-concepts">1. Core Concepts</h2>

            <h3>What is Partitioning?</h3>

            <p>Partitioning in Azure Cosmos DB is the mechanism for distributing data across multiple physical partitions to achieve:</p>
            <ul>
                <li><strong>Horizontal scalability</strong>: Unlimited storage and throughput</li>
                <li><strong>High availability</strong>: Data replication across regions</li>
                <li><strong>Performance</strong>: Parallel query execution</li>
            </ul>

            <h3>Key Terminology</h3>

            <ul>
                <li><strong>Logical Partition</strong>: A set of items with the same partition key value (max 20 GB per logical partition)</li>
                <li><strong>Physical Partition</strong>: A managed storage unit containing multiple logical partitions (managed by Azure)</li>
                <li><strong>Partition Key</strong>: The property used to route data to specific logical partitions</li>
                <li><strong>Hierarchical Partition Keys (HPK)</strong>: Multi-level partition keys for better distribution (up to 3 levels)</li>
            </ul>

            <h3>The 20 GB Logical Partition Limit</h3>

            <p>Traditional single partition keys have a <strong>20 GB limit per logical partition</strong>. When your data exceeds this:</p>
            <ul>
                <li>Use <strong>Hierarchical Partition Keys (HPK)</strong> to overcome this limitation</li>
                <li>HPK allows data to span multiple logical partitions while maintaining query flexibility</li>
                <li>Example: <code>/tenantId</code> (level 1) + <code>/userId</code> (level 2) + <code>/sessionId</code> (level 3)</li>
            </ul>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th style="width: 50%;">‚ùå Single Partition Key (Limited)</th>
                        <th style="width: 50%;">‚úÖ Hierarchical Partition Keys (HPK)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <strong>Structure:</strong><br>
                            Partition Key: <code>/customerId</code>
                        </td>
                        <td>
                            <strong>Structure:</strong><br>
                            HPK: <code>/tenantId</code> + <code>/userId</code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <strong>Distribution:</strong><br>
                            ‚îî‚îÄ‚îÄ Logical Partition 1 (customerId: 'C1') ‚Üí Max: 20 GB<br>
                            ‚îî‚îÄ‚îÄ Logical Partition 2 (customerId: 'C2') ‚Üí Max: 20 GB<br>
                            ‚îî‚îÄ‚îÄ Logical Partition 3 (customerId: 'C3') ‚Üí Max: 20 GB
                        </td>
                        <td>
                            <strong>Distribution:</strong><br>
                            ‚îî‚îÄ‚îÄ Tenant: T1<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;‚îú‚îÄ‚îÄ User: U1 (20 GB)<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;‚îú‚îÄ‚îÄ User: U2 (20 GB)<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;‚îú‚îÄ‚îÄ User: U3 (20 GB)<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;‚îî‚îÄ‚îÄ ... (1000s of users possible!)
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <strong>Limitation:</strong><br>
                            üö´ Each customer limited to 20 GB<br>
                            üö´ Cannot scale beyond this limit
                        </td>
                        <td>
                            <strong>Advantage:</strong><br>
                            ‚úÖ Breaks 20 GB barrier per tenant<br>
                            ‚úÖ Unlimited scalability<br>
                            ‚úÖ Better query flexibility
                        </td>
                    </tr>
                </tbody>
            </table>

            <h2 id="dm-partitioning-strategy">2. Partitioning Strategy</h2>

            <h3>Choosing the Right Partition Key</h3>

            <p>A good partition key should have:</p>

            <h4>1. High Cardinality</h4>
            <ul>
                <li>Many unique values (ideally thousands or more)</li>
                <li>‚úÖ Good: <code>userId</code>, <code>deviceId</code>, <code>orderId</code>, <code>tenantId</code></li>
                <li>‚ùå Bad: <code>country</code>, <code>status</code>, <code>category</code></li>
            </ul>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th style="width: 50%; background-color: #ffe6e6;">‚ùå Bad: Low Cardinality</th>
                        <th style="width: 50%; background-color: #e6ffe6;">‚úÖ Good: High Cardinality</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="background-color: #fff5f5;">
                            <strong>Partition Key:</strong> <code>/status</code>
                        </td>
                        <td style="background-color: #f5fff5;">
                            <strong>Partition Key:</strong> <code>/userId</code>
                        </td>
                    </tr>
                    <tr>
                        <td style="background-color: #fff5f5;">
                            <strong>Data Distribution:</strong><br>
                            üî¥ Partition 'active': <strong>90% of data</strong> ‚Üí HOT PARTITION! ‚ö†Ô∏è<br>
                            üü° Partition 'inactive': 8% of data<br>
                            üü¢ Partition 'pending': 2% of data
                        </td>
                        <td style="background-color: #f5fff5;">
                            <strong>Data Distribution:</strong><br>
                            üü¢ User: user-001 ‚Üí Balanced<br>
                            üü¢ User: user-002 ‚Üí Balanced<br>
                            üü¢ User: user-003 ‚Üí Balanced<br>
                            üü¢ User: user-... ‚Üí Thousands of users, evenly distributed
                        </td>
                    </tr>
                    <tr>
                        <td style="background-color: #fff5f5;">
                            <strong>Problems:</strong><br>
                            ‚ùå Uneven distribution<br>
                            ‚ùå Hot partition causes bottleneck<br>
                            ‚ùå Poor scalability<br>
                            ‚ùå Increased throttling risk
                        </td>
                        <td style="background-color: #f5fff5;">
                            <strong>Benefits:</strong><br>
                            ‚úÖ Even distribution<br>
                            ‚úÖ No hot partitions<br>
                            ‚úÖ Excellent scalability<br>
                            ‚úÖ Consistent performance
                        </td>
                    </tr>
                </tbody>
            </table>

            <h4>2. Even Distribution</h4>
            <ul>
                <li>Data spreads uniformly across partitions</li>
                <li>Prevents hot partitions</li>
                <li>Storage and request rate should be balanced</li>
            </ul>

            <h4>3. Query Alignment</h4>
            <ul>
                <li>Supports most common query patterns</li>
                <li>Minimizes cross-partition queries</li>
                <li>Enables efficient point reads</li>
            </ul>

            <h4>4. Write Distribution</h4>
            <ul>
                <li>Write operations spread evenly</li>
                <li>No single partition becomes a bottleneck</li>
            </ul>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Query Type</th>
                        <th>Example</th>
                        <th>RU Cost</th>
                        <th>Performance</th>
                        <th>Latency</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Point Read</td>
                        <td>Read by id + partition key</td>
                        <td>~1 RU</td>
                        <td>‚ö° Fastest</td>
                        <td>&lt; 10ms</td>
                    </tr>
                    <tr>
                        <td>Single-Partition Query</td>
                        <td><code>WHERE c.userId = 'X'</code></td>
                        <td>~2-10 RUs</td>
                        <td>üöÄ Fast</td>
                        <td>10-50ms</td>
                    </tr>
                    <tr>
                        <td><strong>Cross-Partition Query</strong></td>
                        <td><code>WHERE c.status = 'active'</code></td>
                        <td>~100+ RUs</td>
                        <td>üêå Slow</td>
                        <td>100ms+</td>
                    </tr>
                </tbody>
            </table>

            <h3>Single vs. Hierarchical Partition Keys</h3>

            <h4>Single Partition Key (Traditional)</h4>
            <pre><code>{
        "id": "order-123",
        "customerId": "customer-456",
        "orderDate": "2025-01-15",
        "total": 150.00
    }</code></pre>

            <p><strong>Partition Key</strong>: <code>/customerId</code></p>
            <ul>
                <li>Simple and straightforward</li>
                <li>Limited to 20 GB per customer</li>
                <li>Cross-partition queries when filtering by other properties</li>
            </ul>

            <h4>Hierarchical Partition Keys (HPK)</h4>
            <pre><code>{
        "id": "order-123",
        "tenantId": "tenant-001",
        "customerId": "customer-456",
        "regionId": "us-west",
        "orderDate": "2025-01-15",
        "total": 150.00
    }</code></pre>

            <p><strong>Partition Key Path</strong>: <code>["/tenantId", "/customerId", "/regionId"]</code></p>

            <p><strong>Benefits:</strong></p>
            <ul>
                <li>Overcomes 20 GB logical partition limit</li>
                <li>Better query targeting: Query by tenant, tenant+customer, or tenant+customer+region</li>
                <li>Improved scalability for large datasets</li>
                <li>Flexible query patterns at different hierarchical levels</li>
            </ul>

            <p><strong>When to Use HPK:</strong></p>
            <ul>
                <li>Multi-tenant applications</li>
                <li>When logical partitions might exceed 20 GB</li>
                <li>Need to query at different granularity levels</li>
                <li>IoT scenarios with device hierarchies</li>
            </ul>

            <div class="callout">
                <p><strong>üì¶ SDK Requirements for Hierarchical Partition Keys</strong></p>
                <p>To use Hierarchical Partition Keys (HPK), ensure you're using a compatible SDK version:</p>
                <ul>
                    <li><strong>.NET SDK</strong>: v3.27.0 or higher</li>
                    <li><strong>Java SDK</strong>: v4.42.0 or higher</li>
                    <li><strong>Python SDK</strong>: v4.3.0 or higher</li>
                    <li><strong>Node.js SDK</strong>: v3.17.0 or higher</li>
                </ul>
                <p>Older SDK versions do not support HPK and will result in runtime errors. Always check the latest documentation for SDK updates.</p>
            </div>

            <h2 id="dm-data-modelling-approaches">3. Data Modelling Approaches</h2>

            <div class="mermaid">
            %%{init: {'theme':'default', 'themeVariables': {'fontFamily':'Segoe UI'}, 'flowchart': {'nodeSpacing': 20, 'rankSpacing': 20}}}%%
            flowchart LR
                Start{"**Data Modeling Decision**"}
                Start --> Q1{"Data always 
                accessed together?"}
                Q1 -->|Yes| Q2{"Item size < 2 MB?"}
                Q2 -->|Yes| Embed["‚úÖ EMBED (Denormalize)"]
                Q2 -->|No| Reference["‚úÖ REFERENCE (Normalize)"]
                Q1 -->|No| Q3{"Frequently updated independently?"}
                Q3 -->|Yes| Reference
                Q3 -->|No| Hybrid["‚úÖ HYBRID (Mix of both)"]
                
                style Embed fill:#9f9,stroke:#333,stroke-width:3px
                style Reference fill:#99f,stroke:#333,stroke-width:3px
                style Hybrid fill:#f9c,stroke:#333,stroke-width:3px
                style Start fill:#fc9,stroke:#333,stroke-width:2px
            </div>

            <h3>1. Embedding (Denormalization)</h3>

            <p><strong>When to Embed:</strong></p>
            <ul>
                <li>Data is <strong>always accessed together</strong></li>
                <li>One-to-one or one-to-few relationships</li>
                <li>Child data rarely changes independently</li>
                <li>Total item size stays under 2 MB</li>
            </ul>

            <p><strong>Example: E-commerce Order</strong></p>
            <pre><code>{
        "id": "order-789",
        "customerId": "customer-456",
        "orderDate": "2025-01-15T10:30:00Z",
        "status": "shipped",
        "customer": {
        "name": "John Doe",
        "email": "john@example.com",
        "shippingAddress": {
            "street": "123 Main St",
            "city": "Seattle",
            "state": "WA",
            "zip": "98101"
        }
        },
        "items": [
        {
            "productId": "prod-101",
            "name": "Laptop",
            "quantity": 1,
            "price": 1200.00
        },
        {
            "productId": "prod-202",
            "name": "Mouse",
            "quantity": 2,
            "price": 25.00
        }
        ],
        "total": 1250.00
    }</code></pre>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>Single query retrieves all data</li>
                <li>Lower RU consumption</li>
                <li>Better performance for reads</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>Data duplication</li>
                <li>Updates require updating multiple items</li>
                <li>Item size can grow quickly</li>
            </ul>

            <div class="callout" style="background: #e6ffe6; border-left-color: #32CD32;">
                <h4>Embedding (Denormalization) - Query Pattern</h4>
                <p><strong>Single Query</strong> ‚Üí Order Document (orderId: '789', customerId: '456', customerName: 'John', items: [...], total: 1250)</p>
                <p><strong>Result:</strong> ‚úÖ <strong>Complete Data in 1 Query = Low RU Cost</strong></p>
                <p style="margin-top: 1rem;"><em>All related data retrieved in a single operation. Ideal for read-heavy scenarios where data is always accessed together.</em></p>
            </div>

            <h3>2. Referencing (Normalization)</h3>

            <p><strong>When to Reference:</strong></p>
            <ul>
                <li>Data is <strong>frequently updated independently</strong></li>
                <li>One-to-many or many-to-many relationships</li>
                <li>Embedding would create items > 2 MB</li>
                <li>Different access patterns for related data</li>
            </ul>

            <p><strong>Example: Social Media Platform</strong></p>
            <pre><code>// User Document
    {
        "id": "user-123",
        "userId": "user-123",
        "username": "johndoe",
        "email": "john@example.com",
        "profileImage": "https://...",
        "followerCount": 1250,
        "followingCount": 890
    }

    // Post Document
    {
        "id": "post-456",
        "userId": "user-123",
        "content": "Check out my new blog post!",
        "timestamp": "2025-01-15T14:20:00Z",
        "likes": 45,
        "commentCount": 8
    }

    // Comment Document
    {
        "id": "comment-789",
        "postId": "post-456",
        "userId": "user-999",
        "content": "Great post!",
        "timestamp": "2025-01-15T14:25:00Z"
    }</code></pre>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>No data duplication</li>
                <li>Easier to update independent entities</li>
                <li>Smaller item sizes</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>Multiple queries required</li>
                <li>Higher RU consumption</li>
                <li>Application must handle joins</li>
            </ul>

            <div class="callout" style="background: #fff4e6; border-left-color: #FFA500;">
                <h4>Referencing (Normalization) - Query Pattern</h4>
                <p><strong>Query 1:</strong> Get Post ‚Üí Post Document (postId: '456', userId: '123', content: '...')</p>
                <p><strong>Query 2:</strong> Get User (userId: '123') ‚Üí User Document (userId: '123', username: 'johndoe', email: '...')</p>
                <p><strong>Result:</strong> ‚ö†Ô∏è <strong>Multiple Queries = Higher RU Cost</strong></p>
                <p style="margin-top: 1rem;"><em>Requires separate queries to fetch related data. Application must handle the relationship logic. Better for data that updates frequently and independently.</em></p>
            </div>

            <h3>3. Hybrid Approach (Recommended)</h3>

            <p>Combine embedding and referencing for optimal performance:</p>

            <p><strong>Example: Blog Platform</strong></p>
            <pre><code>{
        "id": "post-123",
        "authorId": "author-456",
        "title": "Guide to Cosmos DB",
        "content": "...",
        "publishedDate": "2025-01-15",
        
        // Embedded: Frequently accessed together
        "authorSummary": {
        "name": "Jane Smith",
        "avatar": "https://...",
        "bio": "Cloud Architect"
        },
        
        // Embedded: Small, bounded collection
        "tags": ["azure", "cosmosdb", "nosql"],
        
        // Referenced: Large, growing collection
        "commentIds": ["comment-1", "comment-2"],
        
        // Aggregated: Computed values
        "stats": {
        "views": 1500,
        "likes": 89,
        "commentCount": 23,
        "lastUpdated": "2025-01-15T18:00:00Z"
        }
    }</code></pre>

            <h2 id="dm-best-practices">4. Best Practices</h2>

            <h3>1. Data Modeling Best Practices</h3>

            <h4>‚úÖ Model for Your Access Patterns</h4>
            <ul>
                <li>Understand your queries <strong>before</strong> designing the schema</li>
                <li>Optimize for the most frequent read/write patterns</li>
                <li>Accept some denormalization for performance</li>
            </ul>

            <h4>‚úÖ Minimize Cross-Partition Queries</h4>
            <ul>
                <li>Design partition keys to support single-partition queries</li>
                <li>Use composite queries within a partition when possible</li>
                <li>Reserve cross-partition queries for occasional admin/analytics tasks</li>
            </ul>

            <h4>‚úÖ Keep Items Under 2 MB</h4>
            <ul>
                <li>Azure Cosmos DB enforces a <strong>2 MB item size limit</strong></li>
                <li>If items approach this limit, consider referencing instead of embedding</li>
                <li>Monitor item sizes as data grows</li>
            </ul>

            <h4>‚úÖ Use Hierarchical Partition Keys for Multi-Tenant Apps</h4>
            <pre><code>{
        "id": "device-001",
        "tenantId": "tenant-123",
        "buildingId": "building-456",
        "floorId": "floor-789",
        "deviceType": "thermostat",
        "temperature": 72.5
    }</code></pre>

            <p><strong>Partition Key</strong>: <code>["/tenantId", "/buildingId", "/floorId"]</code></p>

            <p><strong>Query Flexibility:</strong></p>
            <ul>
                <li>Query all devices in a tenant: <code>WHERE c.tenantId = "tenant-123"</code></li>
                <li>Query devices in a building: <code>WHERE c.tenantId = "tenant-123" AND c.buildingId = "building-456"</code></li>
                <li>Query devices on a floor: <code>WHERE c.tenantId = "tenant-123" AND c.buildingId = "building-456" AND c.floorId = "floor-789"</code></li>
            </ul>

            <h4>‚úÖ Include Computed/Aggregated Values</h4>
            <p>Instead of computing values in queries, store them:</p>
            <pre><code>{
        "id": "product-123",
        "name": "Laptop",
        "reviews": [/* embedded reviews */],
        "reviewStats": {
        "totalReviews": 45,
        "averageRating": 4.5,
        "lastReviewDate": "2025-01-15"
        }
    }</code></pre>

            <h3>2. Partition Key Selection Best Practices</h3>

            <h4>‚úÖ Avoid Low-Cardinality Keys</h4>
            <ul>
                <li><strong>Bad</strong>: <code>/status</code>, <code>/type</code>, <code>/category</code></li>
                <li><strong>Good</strong>: <code>/userId</code>, <code>/orderId</code>, <code>/deviceId</code></li>
            </ul>

            <h4>‚úÖ Test Your Distribution</h4>
            <ul>
                <li>Monitor partition key metrics in Azure Portal</li>
                <li>Check for hot partitions</li>
                <li>Analyze query patterns and RU consumption</li>
            </ul>

            <h4>‚úÖ Plan for Growth</h4>
            <ul>
                <li>Will the partition key work as data scales?</li>
                <li>Will any single partition exceed 20 GB? (If yes, use HPK)</li>
                <li>Will write patterns remain distributed?</li>
            </ul>

            <h3>3. Performance Optimization</h3>

            <h4>‚úÖ Use Point Reads When Possible</h4>
            <p>Most efficient operation - specify both <code>id</code> and partition key:</p>
            <pre><code>ItemResponse&lt;Order&gt; response = await container.ReadItemAsync&lt;Order&gt;(
        id: "order-123",
        partitionKey: new PartitionKey("customer-456")
    );</code></pre>
            <p><strong>Cost</strong>: ~1 RU for 1 KB item</p>

            <h4>‚úÖ Enable Indexing Policy Optimization</h4>
            <p>Exclude unnecessary paths:</p>
            <pre><code>{
        "indexingMode": "consistent",
        "automatic": true,
        "includedPaths": [
        {
            "path": "/*"
        }
        ],
        "excludedPaths": [
        {
            "path": "/largeTextField/*"
        },
        {
            "path": "/metadata/*"
        }
        ]
    }</code></pre>

            <h4>‚úÖ Use TTL for Automatic Cleanup</h4>
            <pre><code>{
        "id": "session-123",
        "userId": "user-456",
        "data": "...",
        "ttl": 3600  // Expires in 1 hour
    }</code></pre>

            <h4>‚úÖ Batch Operations</h4>
            <p>Use transactional batches for related operations:</p>
            <pre><code>TransactionalBatch batch = container.CreateTransactionalBatch(
                new PartitionKey("customer-456")
            );
            batch.CreateItem(order);
            batch.UpsertItem(customerSummary);
            batch.PatchItem("inventory-123", patchOperations);

            TransactionalBatchResponse response = await batch.ExecuteAsync();</code></pre>

            <h2 id="dm-dos-and-donts">5. Do's and Don'ts</h2>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>‚úÖ DO</th>
                        <th>‚ùå DON'T</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Design your data model based on query patterns</td>
                        <td>Use low-cardinality partition keys (e.g., <code>status</code>, <code>country</code>)</td>
                    </tr>
                    <tr>
                        <td>Use hierarchical partition keys for multi-tenant scenarios</td>
                        <td>Ignore the 20 GB logical partition limit</td>
                    </tr>
                    <tr>
                        <td>Embed data that is always accessed together</td>
                        <td>Create hot partitions with uneven distribution</td>
                    </tr>
                    <tr>
                        <td>Denormalize for read-heavy workloads</td>
                        <td>Perform cross-partition queries for high-frequency operations</td>
                    </tr>
                    <tr>
                        <td>Use point reads (id + partition key) whenever possible</td>
                        <td>Normalize excessively (this isn't a relational database)</td>
                    </tr>
                    <tr>
                        <td>Monitor partition metrics and hot partitions</td>
                        <td>Embed unbounded arrays that will grow indefinitely</td>
                    </tr>
                    <tr>
                        <td>Keep items under 2 MB</td>
                        <td>Ignore item size - monitor and prevent > 2 MB items</td>
                    </tr>
                    <tr>
                        <td>Use synthetic partition keys when natural keys don't exist</td>
                        <td>Use sequential IDs as partition keys (creates hot partitions)</td>
                    </tr>
                    <tr>
                        <td>Include timestamp and version fields for auditing</td>
                        <td>Design partition keys based on data residency alone</td>
                    </tr>
                    <tr>
                        <td>Use change feed for downstream processing</td>
                        <td>Forget to handle eventual consistency implications</td>
                    </tr>
                    <tr>
                        <td>Test with production-like data volumes</td>
                        <td>Over-index - exclude unnecessary paths</td>
                    </tr>
                    <tr>
                        <td>Use async/await patterns in your SDK code</td>
                        <td>Ignore RU consumption metrics</td>
                    </tr>
                    <tr>
                        <td>Implement retry logic for 429 errors (rate limiting)</td>
                        <td>Create multiple CosmosClient instances unnecessarily</td>
                    </tr>
                    <tr>
                        <td>Reuse a single CosmosClient instance (singleton pattern)</td>
                        <td>Use SELECT * queries - project only needed fields</td>
                    </tr>
                    <tr>
                        <td>Use the latest SDK version</td>
                        <td>Ignore throttling (429) responses - implement backoff</td>
                    </tr>
                    <tr>
                        <td>Enable diagnostic logging to track latency and performance</td>
                        <td>Skip capacity planning - provision adequate RUs</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="dm-common-patterns">6. Common Patterns</h2>

            <h3>Pattern 1: Multi-Tenant SaaS Application</h3>

            <p><strong>Scenario</strong>: Each tenant has multiple users, each user has multiple sessions</p>

            <div style="background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); border: 2px solid #3b82f6; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #1e40af; margin-top: 0;">Multi-Tenant Architecture with HPK</h4>
                <p><strong>Hierarchical Partition Key:</strong> <code>/tenantId</code> + <code>/userId</code></p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; margin-top: 1rem;">
                    <div style="background: white; border: 1px solid #bfdbfe; border-radius: 0.5rem; padding: 1rem;">
                        <h5 style="color: #3b82f6; margin-top: 0;">üì¶ Tenant 1</h5>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>User A</strong>
                                <ul style="font-size: 0.9em; color: #64748b;">
                                    <li>Session: S1</li>
                                    <li>Session: S2</li>
                                </ul>
                            </li>
                            <li><strong>User B</strong>
                                <ul style="font-size: 0.9em; color: #64748b;">
                                    <li>Session: S3</li>
                                    <li>Session: S4</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    
                    <div style="background: white; border: 1px solid #bfdbfe; border-radius: 0.5rem; padding: 1rem;">
                        <h5 style="color: #3b82f6; margin-top: 0;">üì¶ Tenant 2</h5>
                        <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                            <li><strong>User C</strong>
                                <ul style="font-size: 0.9em; color: #64748b;">
                                    <li>Session: S5</li>
                                </ul>
                            </li>
                            <li><strong>User D</strong>
                                <ul style="font-size: 0.9em; color: #64748b;">
                                    <li>Session: S6</li>
                                    <li>Session: S7</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <p><strong>Data Model with HPK</strong>:</p>
            <pre><code>{
        "id": "session-abc-123",
        "tenantId": "tenant-001",
        "userId": "user-456",
        "sessionId": "session-abc-123",
        "startTime": "2025-01-15T10:00:00Z",
        "endTime": null,
        "activities": [
            {"action": "login", "timestamp": "2025-01-15T10:00:00Z"},
            {"action": "view_dashboard", "timestamp": "2025-01-15T10:01:30Z"}
        ]
    }</code></pre>

            <p><strong>Partition Key</strong>: <code>["/tenantId", "/userId"]</code></p>

            <p><strong>Benefits</strong>:</p>
            <ul>
                <li>Isolate tenant data completely</li>
                <li>Query user sessions efficiently</li>
                <li>Scale beyond 20 GB per tenant</li>
                <li>Support tenant-level analytics</li>
            </ul>

            <h3>Pattern 2: IoT Device Management</h3>

            <p><strong>Scenario</strong>: Millions of devices sending telemetry data</p>

            <div style="background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 2px solid #22c55e; border-radius: 0.5rem; padding: 1.5rem; margin: 1.5rem 0;">
                <h4 style="color: #15803d; margin-top: 0;">IoT Telemetry Flow</h4>
                <p><strong>Partition Key:</strong> <code>/deviceId</code> (ensures even distribution across millions of devices)</p>
                
                <table class="table table-striped" style="margin-top: 1rem; background: white;">
                    <thead>
                        <tr>
                            <th>Device</th>
                            <th>Partition</th>
                            <th>Data Characteristics</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>üì° <strong>Device 001</strong><br><small>Sensor Data</small></td>
                            <td><code>/deviceId = '001'</code></td>
                            <td>Time-series data<br>TTL: 30 days</td>
                        </tr>
                        <tr>
                            <td>üì° <strong>Device 002</strong><br><small>Sensor Data</small></td>
                            <td><code>/deviceId = '002'</code></td>
                            <td>Time-series data<br>TTL: 30 days</td>
                        </tr>
                        <tr>
                            <td>üì° <strong>Device 003</strong><br><small>Sensor Data</small></td>
                            <td><code>/deviceId = '003'</code></td>
                            <td>Time-series data<br>TTL: 30 days</td>
                        </tr>
                        <tr>
                            <td>üì° <strong>Device ...</strong><br><small>Millions of devices</small></td>
                            <td><code>/deviceId = '...'</code></td>
                            <td>‚úÖ Evenly distributed<br>Automatic cleanup</td>
                        </tr>
                    </tbody>
                </table>
                <p style="margin-top: 1rem; font-size: 0.9em; color: #15803d;"><em>üí° Each device has its own partition, enabling efficient time-series queries per device while maintaining even distribution across millions of devices.</em></p>
            </div>

            <p><strong>Data Model</strong>:</p>
            <pre><code>{
        "id": "reading-2025-01-15-10:30:00",
        "deviceId": "device-12345",
        "timestamp": "2025-01-15T10:30:00Z",
        "metrics": {
        "temperature": 72.5,
        "humidity": 45.2,
        "pressure": 1013.25
        },
        "location": {
        "lat": 47.6062,
        "lon": -122.3321
        },
        "ttl": 2592000  // 30 days
    }</code></pre>

            <p><strong>Partition Key</strong>: <code>/deviceId</code></p>

            <p><strong>Benefits</strong>:</p>
            <ul>
                <li>Each device's data in separate partition</li>
                <li>Time-series queries per device are efficient</li>
                <li>TTL automatically removes old data</li>
                <li>Even distribution if device IDs are well-distributed</li>
            </ul>

            <h3>Pattern 3: E-commerce Order Processing</h3>

            <p><strong>Scenario</strong>: Orders with items, customers, and inventory tracking</p>

            <p><strong>Data Model (Hybrid)</strong>:</p>
            <pre><code>// Order Document
    {
        "id": "order-789",
        "orderId": "order-789",
        "customerId": "customer-456",
        "orderDate": "2025-01-15T10:30:00Z",
        "status": "processing",
        
        // Embedded: Customer snapshot at order time
        "customerSnapshot": {
        "name": "John Doe",
        "email": "john@example.com",
        "loyaltyTier": "gold"
        },
        
        // Embedded: Order items
        "items": [
        {
            "productId": "prod-101",
            "name": "Laptop",
            "sku": "LAP-001",
            "quantity": 1,
            "priceAtPurchase": 1200.00
        }
        ],
        
        "totals": {
        "subtotal": 1200.00,
        "tax": 96.00,
        "shipping": 15.00,
        "total": 1311.00
        },
        
        // Reference: Payment handled separately
        "paymentTransactionId": "txn-xyz-789"
    }</code></pre>

            <p><strong>Partition Key</strong>: <code>/customerId</code></p>

            <p><strong>Benefits</strong>:</p>
            <ul>
                <li>Single query retrieves complete order</li>
                <li>Customer's order history in one partition</li>
                <li>Snapshot preserves historical data</li>
                <li>Payment system decoupled</li>
            </ul>

            <h3>Pattern 4: Social Media Feed</h3>

            <p><strong>Scenario</strong>: User posts, comments, and likes</p>

            <p><strong>Data Model</strong>:</p>
            <pre><code>// User's Feed Container (Partitioned by userId)
    {
        "id": "feed-item-123",
        "userId": "user-789",  // Owner of the feed
        "postId": "post-456",
        "authorId": "user-999",
        "authorName": "Jane Smith",
        "authorAvatar": "https://...",
        "contentPreview": "Check out my new...",
        "timestamp": "2025-01-15T14:20:00Z",
        "stats": {
        "likes": 45,
        "comments": 8,
        "shares": 3
        }
    }</code></pre>

            <p><strong>Partition Key</strong>: <code>/userId</code></p>

            <p><strong>Benefits</strong>:</p>
            <ul>
                <li>Fast feed loading (single partition query)</li>
                <li>Denormalized for read performance</li>
                <li>Write amplification (trade-off for read speed)</li>
                <li>Update mechanism needed when posts change</li>
            </ul>

            <h3>Pattern 5: Event Sourcing</h3>

            <p><strong>Scenario</strong>: Store all state changes as events</p>

            <p><strong>Data Model</strong>:</p>
            <pre><code>{
        "id": "event-uuid-123",
        "aggregateId": "order-789",
        "aggregateType": "Order",
        "eventType": "OrderPlaced",
        "eventVersion": 1,
        "timestamp": "2025-01-15T10:30:00Z",
        "data": {
        "customerId": "customer-456",
        "items": [...],
        "total": 1311.00
        },
        "metadata": {
        "userId": "user-123",
        "correlationId": "corr-abc"
        }
    }</code></pre>

            <p><strong>Partition Key</strong>: <code>/aggregateId</code></p>

            <p><strong>Benefits</strong>:</p>
            <ul>
                <li>Complete audit trail</li>
                <li>Can reconstruct state at any point</li>
                <li>Supports CQRS pattern</li>
                <li>Use change feed for projections</li>
            </ul>

            <h3>Quick Reference Checklist</h3>

            <h4>Before Creating a Container</h4>

            <ul class="list-style-none">
                <li>‚òê Identified most common query patterns</li>
                <li>‚òê Chosen partition key with high cardinality</li>
                <li>‚òê Verified even data distribution</li>
                <li>‚òê Determined if HPK is needed (multi-tenant or >20GB partitions)</li>
                <li>‚òê Planned indexing policy</li>
                <li>‚òê Estimated RU requirements</li>
                <li>‚òê Considered TTL requirements</li>
            </ul>

            <h4>Before Designing Documents</h4>

            <ul class="list-style-none">
                <li>‚òê Decided embed vs. reference strategy</li>
                <li>‚òê Ensured items stay under 2 MB</li>
                <li>‚òê Included necessary computed/aggregated fields</li>
                <li>‚òê Added timestamp and version fields</li>
                <li>‚òê Planned for data growth</li>
                <li>‚òê Considered consistency requirements</li>
            </ul>

            <h4>Before Going to Production</h4>

            <ul class="list-style-none">
                <li>‚òê Tested with production-like data volumes</li>
                <li>‚òê Monitored RU consumption</li>
                <li>‚òê Checked for hot partitions</li>
                <li>‚òê Implemented retry logic for 429 errors</li>
                <li>‚òê Set up monitoring and alerts</li>
                <li>‚òê Reviewed indexing policy efficiency</li>
                <li>‚òê Tested disaster recovery procedures</li>
                <li>‚òê Configured appropriate consistency level</li>
            </ul>

            <h2 id="dm-summary">7. Summary</h2>

            <p><strong>Key Takeaways:</strong></p>

            <ol>
                <li><strong>Partition Key is Critical</strong>: Choose wisely based on access patterns, cardinality, and distribution</li>
                <li><strong>Use Hierarchical Partition Keys</strong>: For multi-tenant apps and to overcome 20 GB limit</li>
                <li><strong>Embrace Denormalization</strong>: This isn't a relational database - optimize for queries</li>
                <li><strong>Monitor Everything</strong>: Track RUs, latency, hot partitions, and diagnostics</li>
                <li><strong>Keep Items Small</strong>: Stay well under the 2 MB limit</li>
                <li><strong>Test at Scale</strong>: Production-like testing reveals real-world issues</li>
                <li><strong>Use the Right Tools</strong>: VS Code extension and emulator for development</li>
            </ol>

            <div class="callout">
                <p><strong>Remember</strong>: Cosmos DB is optimized for massive scale and global distribution. Design your data model to leverage these strengths, not to replicate relational database patterns.</p>
            </div>

            </section>

            <section id="cosmosdb-querying-data" role="article">
            <h1>Querying Data - SQL API</h1>
            <span class="badge">queries</span>
            <span class="badge">sql</span>
            <span class="badge">nosql</span>

            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#qd-basic-select">Basic SELECT Queries</a></li>
                <li><a href="#qd-where-clause">WHERE Clause - Filtering</a></li>
                <li><a href="#qd-nested-properties">Nested Property Queries</a></li>
                <li><a href="#qd-array-operations">Array Operations</a></li>
                <li><a href="#qd-aggregate-functions">Aggregate Functions</a></li>
                <li><a href="#qd-order-by">ORDER BY</a></li>
                <li><a href="#qd-string-functions">String Functions</a></li>
                <li><a href="#qd-math-functions">Math Functions</a></li>
                <li><a href="#qd-type-checking">Type Checking Functions</a></li>
                <li><a href="#qd-date-time">Date and Time Functions</a></li>
                <li><a href="#qd-conditional-logic">Conditional Logic</a></li>
                <li><a href="#qd-subqueries">Subqueries and Advanced Queries</a></li>
                <li><a href="#qd-join-operations">JOIN Operations</a></li>
                <li><a href="#qd-distinct-top">DISTINCT and TOP</a></li>
                <li><a href="#qd-group-by">GROUP BY</a></li>
                <li><a href="#qd-advanced-arrays">Advanced Array Functions</a></li>
                <li><a href="#qd-geospatial">Geospatial Queries</a></li>
                <li><a href="#qd-cross-partition">Cross-Partition Queries</a></li>
                <li><a href="#qd-system-functions">Special System Functions</a></li>
                <li><a href="#qd-optimization">Performance Optimization Patterns</a></li>
                <li><a href="#qd-summary">Summary of Query Capabilities</a></li>
                <li><a href="#qd-best-practices">Best Practices</a></li>
                <li><a href="#qd-ru-guidelines">RU Cost Guidelines</a></li>
            </ol>

            <h2 id="qd-test-data">Test Data Setup</h2>

            <h3>Sample Container: Products</h3>
            <p><strong>Partition Key</strong>: <code>/category</code></p>

            <pre><code>[
    {
        "id": "1",
        "category": "Electronics",
        "name": "Laptop Pro 15",
        "brand": "TechCorp",
        "price": 1299.99,
        "stock": 45,
        "specifications": {
            "ram": "16GB",
            "storage": "512GB SSD",
            "processor": "Intel i7"
        },
        "tags": ["computers", "laptops", "premium"],
        "ratings": [5, 4, 5, 4, 5],
        "inStock": true,
        "releaseDate": "2024-03-15T00:00:00Z"
    },
    {
        "id": "2",
        "category": "Electronics",
        "name": "Wireless Mouse",
        "brand": "TechCorp",
        "price": 29.99,
        "stock": 150,
        "specifications": {
            "connectivity": "Bluetooth",
            "battery": "AA"
        },
        "tags": ["accessories", "wireless"],
        "ratings": [4, 4, 3, 5, 4],
        "inStock": true,
        "releaseDate": "2023-06-10T00:00:00Z"
    },
    {
        "id": "3",
        "category": "Books",
        "name": "Cloud Computing Guide",
        "brand": "TechPublishers",
        "price": 49.99,
        "stock": 0,
        "author": "Jane Smith",
        "pages": 450,
        "tags": ["technical", "cloud", "azure"],
        "ratings": [5, 5, 5, 4],
        "inStock": false,
        "releaseDate": "2024-01-20T00:00:00Z"
    },
    {
        "id": "4",
        "category": "Electronics",
        "name": "4K Monitor",
        "brand": "DisplayMax",
        "price": 599.99,
        "stock": 25,
        "specifications": {
            "resolution": "3840x2160",
            "size": "27 inch",
            "refreshRate": "60Hz"
        },
        "tags": ["monitors", "4k", "display"],
        "ratings": [5, 5, 4, 5, 5, 4],
        "inStock": true,
        "releaseDate": "2023-11-05T00:00:00Z"
    },
    {
        "id": "5",
        "category": "Books",
        "name": "Data Structures and Algorithms",
        "brand": "CodePress",
        "price": 59.99,
        "stock": 30,
        "author": "John Doe",
        "pages": 600,
        "tags": ["programming", "algorithms", "technical"],
        "ratings": [5, 4, 5, 5],
        "inStock": true,
        "releaseDate": "2023-09-12T00:00:00Z"
    },
    {
        "id": "6",
        "category": "Furniture",
        "name": "Ergonomic Office Chair",
        "brand": "ComfortPlus",
        "price": 349.99,
        "stock": 12,
        "specifications": {
            "material": "Mesh",
            "adjustable": true,
            "warranty": "5 years"
        },
        "tags": ["office", "furniture", "ergonomic"],
        "ratings": [4, 5, 4, 4],
        "inStock": true,
        "releaseDate": "2024-02-28T00:00:00Z"
    }
]</code></pre>

            <h2 id="qd-basic-select">1. Basic SELECT Queries</h2>

            <h3>1.1 Select All Documents</h3>
            <pre><code>SELECT * FROM c</code></pre>
            <p><strong>Result</strong>: Returns all 6 documents with all properties.</p>
            <p><strong>RU Charge</strong>: ~3 RUs (depends on document size)</p>

            <h3>1.2 Select Specific Properties</h3>
            <pre><code>SELECT c.id, c.name, c.price FROM c</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"id": "1", "name": "Laptop Pro 15", "price": 1299.99},
    {"id": "2", "name": "Wireless Mouse", "price": 29.99},
    {"id": "3", "name": "Cloud Computing Guide", "price": 49.99},
    {"id": "4", "name": "4K Monitor", "price": 599.99},
    {"id": "5", "name": "Data Structures and Algorithms", "price": 59.99},
    {"id": "6", "name": "Ergonomic Office Chair", "price": 349.99}
]</code></pre>

            <h3>1.3 Select with Aliases</h3>
            <pre><code>SELECT c.id AS productId, 
        c.name AS productName, 
        c.price AS cost 
FROM c</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"productId": "1", "productName": "Laptop Pro 15", "cost": 1299.99},
    {"productId": "2", "productName": "Wireless Mouse", "cost": 29.99}
    // ... etc
]</code></pre>

            <h2 id="qd-where-clause">2. WHERE Clause - Filtering</h2>

            <h3>2.1 Equality Filter</h3>
            <pre><code>SELECT * FROM c WHERE c.category = "Electronics"</code></pre>
            <p><strong>Result</strong>: Returns 3 documents (id: 1, 2, 4)</p>
            <p><strong>RU Charge</strong>: ~3 RUs (efficient with partition key)</p>

            <h3>2.2 Comparison Operators</h3>
            <pre><code>SELECT c.name, c.price 
FROM c 
WHERE c.price > 100 AND c.price < 700</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"name": "Laptop Pro 15", "price": 1299.99},
    {"name": "4K Monitor", "price": 599.99},
    {"name": "Ergonomic Office Chair", "price": 349.99}
]</code></pre>

            <h3>2.3 IN Operator</h3>
            <pre><code>SELECT c.name, c.category 
FROM c 
WHERE c.category IN ("Electronics", "Books")</code></pre>
            <p><strong>Result</strong>: Returns 5 documents from Electronics and Books categories.</p>

            <h3>2.4 Boolean Conditions</h3>
            <pre><code>SELECT c.name, c.stock 
FROM c 
WHERE c.inStock = true</code></pre>
        <p><strong>Result</strong>: Returns 5 documents (all except the out-of-stock book).</p>

            <h3>2.5 NOT and OR Operators</h3>
            <pre><code>SELECT c.name, c.price 
FROM c 
WHERE c.category = "Electronics" OR c.price < 60</code></pre>
            <p><strong>Result</strong>: Returns Electronics items plus any item under $60.</p>

            <h2 id="qd-nested-properties">3. Nested Property Queries</h2>

            <h3>3.1 Access Nested Properties</h3>
            <pre><code>SELECT c.name, c.specifications.ram, c.specifications.storage 
FROM c 
WHERE IS_DEFINED(c.specifications.ram)</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {
        "name": "Laptop Pro 15",
        "ram": "16GB",
        "storage": "512GB SSD"
    }
]</code></pre>

            <h3>3.2 Filter by Nested Property</h3>
            <pre><code>SELECT c.name, c.specifications 
FROM c 
WHERE c.specifications.adjustable = true</code></pre>
        <p><strong>Result</strong>:</p>
        <pre><code>[
    {
        "name": "Ergonomic Office Chair",
        "specifications": {
            "material": "Mesh",
            "adjustable": true,
            "warranty": "5 years"
        }
    }
]</code></pre>

            <h2 id="qd-array-operations">4. Array Operations</h2>

            <h3>4.1 ARRAY_CONTAINS</h3>
            <pre><code>SELECT c.name, c.tags 
FROM c 
WHERE ARRAY_CONTAINS(c.tags, "technical")</code></pre>
        <p><strong>Result</strong>:</p>
        <pre><code>[
    {"name": "Cloud Computing Guide", "tags": ["technical", "cloud", "azure"]},
    {"name": "Data Structures and Algorithms", "tags": ["programming", "algorithms", "technical"]}
]</code></pre>

            <h3>4.2 ARRAY_CONTAINS with Object</h3>
            <pre><code>-- If you have complex objects in arrays
SELECT c.name 
FROM c 
WHERE ARRAY_CONTAINS(c.tags, "laptops", true)</code></pre>
            <p><strong>Result</strong>: Returns "Laptop Pro 15"</p>

            <h3>4.3 ARRAY_LENGTH</h3>
            <pre><code>SELECT c.name, ARRAY_LENGTH(c.ratings) AS ratingCount 
FROM c 
WHERE ARRAY_LENGTH(c.ratings) > 4</code></pre>
        <p><strong>Result</strong>:</p>
        <pre><code>[
    {"name": "Laptop Pro 15", "ratingCount": 5},
    {"name": "Wireless Mouse", "ratingCount": 5},
    {"name": "4K Monitor", "ratingCount": 6}
]</code></pre>

            <h3>4.4 Array Iteration with JOIN</h3>
            <pre><code>SELECT c.name, t AS tag 
FROM c 
JOIN t IN c.tags 
WHERE c.category = "Electronics"</code></pre>
        <p><strong>Result</strong>:</p>
        <pre><code>[
    {"name": "Laptop Pro 15", "tag": "computers"},
    {"name": "Laptop Pro 15", "tag": "laptops"},
    {"name": "Laptop Pro 15", "tag": "premium"},
    {"name": "Wireless Mouse", "tag": "accessories"},
    {"name": "Wireless Mouse", "tag": "wireless"},
    {"name": "4K Monitor", "tag": "monitors"},
    {"name": "4K Monitor", "tag": "4k"},
    {"name": "4K Monitor", "tag": "display"}
]</code></pre>

            <h3>4.5 Filter on Array Elements</h3>
            <pre><code>SELECT c.name, r AS rating 
FROM c 
JOIN r IN c.ratings 
WHERE r = 5</code></pre>
            <p><strong>Result</strong>: Returns document name and each instance of a 5-star rating.</p>

            <h2 id="qd-aggregate-functions">5. Aggregate Functions</h2>

            <h3>5.1 COUNT</h3>
            <pre><code>SELECT VALUE COUNT(1) FROM c</code></pre>
            <p><strong>Result</strong>: <code>6</code></p>

            <h3>5.2 COUNT with Filter</h3>
            <pre><code>SELECT VALUE COUNT(1) 
FROM c 
WHERE c.category = "Electronics"</code></pre>
            <p><strong>Result</strong>: <code>3</code></p>

            <h3>5.3 SUM</h3>
            <pre><code>SELECT VALUE SUM(c.price) 
FROM c 
WHERE c.category = "Electronics"</code></pre>
            <p><strong>Result</strong>: <code>1929.97</code> (1299.99 + 29.99 + 599.99)</p>

            <h3>5.4 AVG</h3>
            <pre><code>SELECT VALUE AVG(c.price) FROM c</code></pre>
            <p><strong>Result</strong>: <code>398.32</code> (average of all prices)</p>

            <h3>5.5 MIN and MAX</h3>
            <pre><code>SELECT VALUE MIN(c.price) AS minPrice FROM c</code></pre>
            <p><strong>Result</strong>: <code>29.99</code></p>
            <pre><code>SELECT VALUE MAX(c.price) AS maxPrice FROM c</code></pre>
            <p><strong>Result</strong>: <code>1299.99</code></p>

            <h3>5.6 Multiple Aggregates</h3>
            <pre><code>SELECT 
    COUNT(1) AS totalProducts,
    SUM(c.price) AS totalValue,
    AVG(c.price) AS avgPrice,
    MIN(c.price) AS cheapest,
    MAX(c.price) AS expensive
FROM c
WHERE c.inStock = true</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {
        "totalProducts": 5,
        "totalValue": 2339.95,
        "avgPrice": 467.99,
        "cheapest": 29.99,
        "expensive": 1299.99
    }
]</code></pre>

            <h2 id="qd-order-by">6. ORDER BY</h2>

            <h3>6.1 Ascending Order</h3>
            <pre><code>SELECT c.name, c.price 
FROM c 
ORDER BY c.price ASC</code></pre>
            <p><strong>Result</strong>: Products sorted from cheapest to most expensive.</p>

            <h3>6.2 Descending Order</h3>
            <pre><code>SELECT c.name, c.price 
FROM c 
ORDER BY c.price DESC</code></pre>
            <p><strong>Result</strong>: Products sorted from most expensive to cheapest.</p>

            <h3>6.3 Multiple Sort Criteria</h3>
            <pre><code>SELECT c.category, c.name, c.price 
FROM c 
ORDER BY c.category ASC, c.price DESC</code></pre>
            <p><strong>Result</strong>: Sorted by category first, then by price within each category.</p>

            <h2 id="qd-string-functions">7. String Functions</h2>

            <h3>7.1 STARTSWITH</h3>
            <pre><code>SELECT c.name 
FROM c 
WHERE STARTSWITH(c.name, "Laptop")</code></pre>
            <p><strong>Result</strong>: <code>["Laptop Pro 15"]</code></p>

            <h3>7.2 ENDSWITH</h3>
            <pre><code>SELECT c.name 
FROM c 
WHERE ENDSWITH(c.name, "Chair")</code></pre>
            <p><strong>Result</strong>: <code>["Ergonomic Office Chair"]</code></p>

            <h3>7.3 CONTAINS</h3>
            <pre><code>SELECT c.name 
FROM c 
WHERE CONTAINS(c.name, "Monitor")</code></pre>
            <p><strong>Result</strong>: <code>["4K Monitor"]</code></p>

            <h3>7.4 UPPER and LOWER</h3>
            <pre><code>SELECT c.name, 
    UPPER(c.name) AS upperName, 
    LOWER(c.name) AS lowerName 
FROM c 
WHERE c.id = "1"</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {
        "name": "Laptop Pro 15",
        "upperName": "LAPTOP PRO 15",
        "lowerName": "laptop pro 15"
    }
]</code></pre>

            <h3>7.5 CONCAT</h3>
            <pre><code>SELECT CONCAT(c.brand, " - ", c.name) AS fullName, c.price 
            FROM c</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"fullName": "TechCorp - Laptop Pro 15", "price": 1299.99},
    {"fullName": "TechCorp - Wireless Mouse", "price": 29.99}
    // ... etc
]</code></pre>

            <h3>7.6 SUBSTRING</h3>
            <pre><code>SELECT c.name, SUBSTRING(c.name, 0, 10) AS shortName 
FROM c</code></pre>
            <p><strong>Result</strong>: First 10 characters of each product name.</p>

            <h3>7.7 LENGTH</h3>
            <pre><code>SELECT c.name, LENGTH(c.name) AS nameLength 
FROM c 
WHERE LENGTH(c.name) > 15</code></pre>
            <p><strong>Result</strong>: Products with names longer than 15 characters.</p>

            <h2 id="qd-math-functions">8. Math Functions</h2>

            <h3>8.1 ROUND, FLOOR, CEILING</h3>
            <pre><code>SELECT c.name,
    c.price,
    ROUND(c.price) AS rounded,
    FLOOR(c.price) AS floored,
    CEILING(c.price) AS ceiled
FROM c
WHERE c.id = "1"</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {
        "name": "Laptop Pro 15",
        "price": 1299.99,
        "rounded": 1300,
        "floored": 1299,
        "ceiled": 1300
    }
]</code></pre>

            <h3>8.2 ABS (Absolute Value)</h3>
            <pre><code>SELECT c.name, 
    ABS(c.price - 500) AS priceDeviation 
FROM c</code></pre>
            <p><strong>Result</strong>: Shows absolute difference from $500.</p>

            <h3>8.3 Mathematical Operations</h3>
            <pre><code>SELECT c.name,
    c.price,
    c.price * 1.08 AS priceWithTax,
    c.price * 0.9 AS discountedPrice
FROM c</code></pre>
            <p><strong>Result</strong>: Calculates price with 8% tax and 10% discount.</p>

            <h2 id="qd-type-checking">9. Type Checking Functions</h2>

            <h3>9.1 IS_DEFINED</h3>
            <pre><code>SELECT c.name, c.author 
FROM c 
WHERE IS_DEFINED(c.author)</code></pre>
            <p><strong>Result</strong>: Returns only books with author property (id: 3, 5).</p>

            <h3>9.2 IS_NULL</h3>
            <pre><code>SELECT c.name 
FROM c 
WHERE IS_NULL(c.author)</code></pre>
            <p><strong>Result</strong>: Returns products without author property (or with null value).</p>

            <h3>9.3 IS_ARRAY</h3>
            <pre><code>SELECT c.name, c.tags 
FROM c 
WHERE IS_ARRAY(c.tags)</code></pre>
            <p><strong>Result</strong>: Returns all documents where tags is an array.</p>

            <h3>9.4 IS_OBJECT</h3>
            <pre><code>SELECT c.name, c.specifications 
FROM c 
WHERE IS_OBJECT(c.specifications)</code></pre>
            <p><strong>Result</strong>: Returns documents with specifications as an object.</p>

            <h3>9.5 IS_NUMBER, IS_STRING, IS_BOOL</h3>
            <pre><code>SELECT c.name,
    IS_NUMBER(c.price) AS isPriceNumber,
    IS_STRING(c.name) AS isNameString,
    IS_BOOL(c.inStock) AS isInStockBoolean
FROM c
WHERE c.id = "1"</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {
        "name": "Laptop Pro 15",
        "isPriceNumber": true,
        "isNameString": true,
        "isInStockBoolean": true
    }
]</code></pre>

            <h2 id="qd-date-time">10. Date and Time Functions</h2>

            <h3>10.1 GetCurrentDateTime</h3>
            <pre><code>SELECT GetCurrentDateTime() AS currentTime</code></pre>
            <p><strong>Result</strong>: <code>"2025-11-25T10:30:45.123Z"</code></p>

            <h3>10.2 Date Comparison</h3>
            <pre><code>SELECT c.name, c.releaseDate 
FROM c 
WHERE c.releaseDate > "2024-01-01T00:00:00Z"</code></pre>
            <p><strong>Result</strong>: Returns products released after January 1, 2024.</p>

            <h3>10.3 DateTimeFromParts</h3>
            <pre><code>SELECT c.name,
    c.releaseDate,
    DateTimeFromParts(2024, 12, 25) AS christmas
FROM c
WHERE c.id = "1"</code></pre>
            <p><strong>Result</strong>: Creates a datetime from year, month, day components.</p>

            <h3>10.4 Date Part Extraction</h3>
            <pre><code>SELECT c.name,
    DateTimePart("year", c.releaseDate) AS releaseYear,
    DateTimePart("month", c.releaseDate) AS releaseMonth
FROM c</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"name": "Laptop Pro 15", "releaseYear": 2024, "releaseMonth": 3},
    {"name": "Wireless Mouse", "releaseYear": 2023, "releaseMonth": 6}
    // ... etc
]</code></pre>

            <h2 id="qd-conditional-logic">11. Conditional Logic</h2>

            <h3>11.1 Ternary Operator</h3>
            <pre><code>SELECT c.name,
    c.stock,
    (c.stock > 50 ? "High Stock" : "Low Stock") AS stockLevel
FROM c</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"name": "Laptop Pro 15", "stock": 45, "stockLevel": "Low Stock"},
    {"name": "Wireless Mouse", "stock": 150, "stockLevel": "High Stock"}
    // ... etc
]</code></pre>

            <h3>11.2 Complex Conditional</h3>
            <pre><code>SELECT c.name,
    c.price,
    (c.price < 50 ? "Budget" :
    c.price < 300 ? "Mid-Range" :
    "Premium") AS priceCategory
FROM c</code></pre>
            <p><strong>Result</strong>: Categorizes products by price range.</p>

            <h2 id="qd-subqueries">12. Subqueries and Advanced Queries</h2>

            <h3>12.1 Subquery in SELECT</h3>
            <pre><code>SELECT c.name,
    c.price,
    (SELECT VALUE AVG(r) FROM r IN c.ratings) AS avgRating
FROM c
WHERE IS_DEFINED(c.ratings)</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"name": "Laptop Pro 15", "price": 1299.99, "avgRating": 4.6},
    {"name": "Wireless Mouse", "price": 29.99, "avgRating": 4.0},
    {"name": "Cloud Computing Guide", "price": 49.99, "avgRating": 4.75}
    // ... etc
]</code></pre>

            <h3>12.2 Filtering with Subquery Results</h3>
            <pre><code>SELECT c.name, c.tags 
FROM c 
WHERE (SELECT VALUE COUNT(1) FROM t IN c.tags) > 2</code></pre>
            <p><strong>Result</strong>: Products with more than 2 tags.</p>

            <h2 id="qd-join-operations">13. JOIN Operations</h2>

            <h3>13.1 Self JOIN (Array Expansion)</h3>
            <pre><code>SELECT c.name, tag.value AS tagName
FROM c
JOIN tag IN c.tags
WHERE c.category = "Books"</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"name": "Cloud Computing Guide", "tagName": "technical"},
    {"name": "Cloud Computing Guide", "tagName": "cloud"},
    {"name": "Cloud Computing Guide", "tagName": "azure"},
    {"name": "Data Structures and Algorithms", "tagName": "programming"},
    {"name": "Data Structures and Algorithms", "tagName": "algorithms"},
    {"name": "Data Structures and Algorithms", "tagName": "technical"}
]</code></pre>

            <h3>13.2 Multiple JOINs</h3>
            <pre><code>SELECT c.name, r AS rating, t AS tag
FROM c
JOIN r IN c.ratings
JOIN t IN c.tags
WHERE c.id = "2"</code></pre>
            <p><strong>Result</strong>: Cartesian product of ratings and tags for the wireless mouse.</p>

            <h2 id="qd-distinct-top">14. DISTINCT and TOP</h2>

            <h3>14.1 SELECT DISTINCT</h3>
            <pre><code>SELECT DISTINCT c.category FROM c</code></pre>
            <p><strong>Result</strong>: <code>["Electronics", "Books", "Furniture"]</code></p>

            <h3>14.2 SELECT DISTINCT with VALUE</h3>
            <pre><code>SELECT DISTINCT VALUE c.brand FROM c</code></pre>
            <p><strong>Result</strong>: <code>["TechCorp", "TechPublishers", "DisplayMax", "CodePress", "ComfortPlus"]</code></p>

            <h3>14.3 TOP</h3>
            <pre><code>SELECT TOP 3 c.name, c.price 
FROM c 
ORDER BY c.price DESC</code></pre>
            <p><strong>Result</strong>: Returns the 3 most expensive products.</p>

            <h3>14.4 OFFSET LIMIT (Pagination)</h3>
            <pre><code>SELECT c.name, c.price 
FROM c 
ORDER BY c.price 
OFFSET 2 LIMIT 3</code></pre>
            <p><strong>Result</strong>: Skips first 2 results, returns next 3 (pagination).</p>

            <h2 id="qd-group-by">15. GROUP BY</h2>

            <h3>15.1 Basic GROUP BY</h3>
            <pre><code>SELECT c.category, COUNT(1) AS productCount 
FROM c 
GROUP BY c.category</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"category": "Electronics", "productCount": 3},
    {"category": "Books", "productCount": 2},
    {"category": "Furniture", "productCount": 1}
]</code></pre>

            <h3>15.2 GROUP BY with Multiple Aggregates</h3>
            <pre><code>SELECT c.category,
    COUNT(1) AS count,
    SUM(c.price) AS totalValue,
    AVG(c.price) AS avgPrice,
    MIN(c.price) AS minPrice,
    MAX(c.price) AS maxPrice
FROM c
GROUP BY c.category</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {
        "category": "Electronics",
        "count": 3,
        "totalValue": 1929.97,
        "avgPrice": 643.32,
        "minPrice": 29.99,
        "maxPrice": 1299.99
    },
    {
        "category": "Books",
        "count": 2,
        "totalValue": 109.98,
        "avgPrice": 54.99,
        "minPrice": 49.99,
        "maxPrice": 59.99
    },
    {
        "category": "Furniture",
        "count": 1,
        "totalValue": 349.99,
        "avgPrice": 349.99,
        "minPrice": 349.99,
        "maxPrice": 349.99
    }
]</code></pre>

            <h3>15.3 GROUP BY with Boolean</h3>
            <pre><code>SELECT c.inStock,
    COUNT(1) AS productCount,
    AVG(c.price) AS avgPrice
FROM c
GROUP BY c.inStock</code></pre>
            <p><strong>Result</strong>:</p>
            <pre><code>[
    {"inStock": true, "productCount": 5, "avgPrice": 467.99},
    {"inStock": false, "productCount": 1, "avgPrice": 49.99}
]</code></pre>

            <h2 id="qd-advanced-arrays">16. Advanced Array Functions</h2>

            <h3>16.1 ARRAY_SLICE</h3>
            <pre><code>SELECT c.name,
    ARRAY_SLICE(c.ratings, 0, 3) AS firstThreeRatings
FROM c
WHERE IS_DEFINED(c.ratings)</code></pre>
            <p><strong>Result</strong>: Returns first 3 ratings from each product.</p>

            <h3>16.2 ARRAY_CONCAT</h3>
            <pre><code>SELECT c.name,
    ARRAY_CONCAT(c.tags, ["featured", "sale"]) AS updatedTags
FROM c
WHERE c.id = "1"</code></pre>
            <p><strong>Result</strong>: Concatenates additional tags to existing array.</p>

            <h2 id="qd-geospatial">17. Geospatial Queries (if location data exists)</h2>

            <h3>Sample Data with Location</h3>
            <pre><code>{
    "id": "store1",
    "name": "Downtown Store",
    "location": {
        "type": "Point",
        "coordinates": [-122.131577, 47.678581]
    }
}</code></pre>

            <h3>17.1 ST_DISTANCE</h3>
            <pre><code>SELECT c.name,
    ST_DISTANCE(c.location, {
        "type": "Point",
        "coordinates": [-122.121, 47.671]
    }) AS distanceInMeters
FROM c
WHERE IS_DEFINED(c.location)</code></pre>

            <h3>17.2 ST_WITHIN</h3>
            <pre><code>SELECT c.name
FROM c
WHERE ST_WITHIN(c.location, {
    "type": "Polygon",
    "coordinates": [[
        [-122.5, 47.5],
        [-122.0, 47.5],
        [-122.0, 47.8],
        [-122.5, 47.8],
        [-122.5, 47.5]
    ]]
})</code></pre>

            <h2 id="qd-cross-partition">18. Cross-Partition Queries</h2>

            <h3>18.1 Query Across All Partitions</h3>
            <pre><code>SELECT c.category, COUNT(1) AS count
FROM c
GROUP BY c.category</code></pre>
            <p><strong>Note</strong>: This queries all partitions. Higher RU cost (~10-15 RUs).</p>

            <h3>18.2 Single Partition Query (Efficient)</h3>
            <pre><code>SELECT * FROM c WHERE c.category = "Electronics"</code></pre>
            <p><strong>Note</strong>: Targets single partition. Lower RU cost (~3 RUs).</p>

            <h2 id="qd-system-functions">19. Special System Functions</h2>

            <h3>19.1 Document Metadata</h3>
            <pre><code>SELECT c.id, 
    c._ts AS timestamp,
    c._etag AS etag
FROM c</code></pre>
            <p><strong>Result</strong>: Returns system-generated metadata.</p>

            <h3>19.2 UUIDV4</h3>
            <pre><code>SELECT UUIDV4() AS newId</code></pre>
            <p><strong>Result</strong>: Generates a new UUID v4.</p>

            <h2 id="qd-optimization">20. Performance Optimization Patterns</h2>

            <h3>20.1 Use Partition Key in WHERE</h3>
            <pre><code>-- GOOD: Single partition query
SELECT * FROM c WHERE c.category = "Electronics" AND c.price > 100

-- AVOID: Cross-partition without partition key
SELECT * FROM c WHERE c.price > 100</code></pre>

            <h3>20.2 Project Only Needed Fields</h3>
            <pre><code>-- GOOD: Select specific fields
SELECT c.id, c.name, c.price FROM c

-- AVOID: Select all when not needed
SELECT * FROM c</code></pre>

            <h3>20.3 Use Indexes Effectively</h3>
            <pre><code>-- Ensure indexed properties in WHERE
SELECT * FROM c WHERE c.inStock = true AND c.category = "Books"</code></pre>

            <h2 id="qd-summary">21. Summary of Query Capabilities</h2>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Features</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Basic Queries</strong></td>
                        <td>SELECT, WHERE, ORDER BY, TOP, OFFSET LIMIT</td>
                    </tr>
                    <tr>
                        <td><strong>Operators</strong></td>
                        <td>=, !=, &lt;, &gt;, &lt;=, &gt;=, IN, AND, OR, NOT</td>
                    </tr>
                    <tr>
                        <td><strong>Aggregates</strong></td>
                        <td>COUNT, SUM, AVG, MIN, MAX, GROUP BY</td>
                    </tr>
                    <tr>
                        <td><strong>String Functions</strong></td>
                        <td>CONCAT, CONTAINS, STARTSWITH, ENDSWITH, UPPER, LOWER, LENGTH, SUBSTRING</td>
                    </tr>
                    <tr>
                        <td><strong>Math Functions</strong></td>
                        <td>ROUND, FLOOR, CEILING, ABS, +, -, *, /</td>
                    </tr>
                    <tr>
                        <td><strong>Array Functions</strong></td>
                        <td>ARRAY_CONTAINS, ARRAY_LENGTH, ARRAY_SLICE, ARRAY_CONCAT, JOIN</td>
                    </tr>
                    <tr>
                        <td><strong>Type Checking</strong></td>
                        <td>IS_DEFINED, IS_NULL, IS_ARRAY, IS_OBJECT, IS_NUMBER, IS_STRING, IS_BOOL</td>
                    </tr>
                    <tr>
                        <td><strong>Date/Time</strong></td>
                        <td>GetCurrentDateTime, DateTimeFromParts, DateTimePart</td>
                    </tr>
                    <tr>
                        <td><strong>Conditionals</strong></td>
                        <td>Ternary operator (? :)</td>
                    </tr>
                    <tr>
                        <td><strong>Geospatial</strong></td>
                        <td>ST_DISTANCE, ST_WITHIN, ST_INTERSECTS</td>
                    </tr>
                    <tr>
                        <td><strong>Advanced</strong></td>
                        <td>Subqueries, DISTINCT, VALUE, Nested properties</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="qd-best-practices">22. Best Practices</h2>

            <div class="callout">
                <ol>
                    <li><strong>Always include partition key in WHERE clause</strong> for efficient queries</li>
                    <li><strong>Use indexes</strong> on frequently queried properties</li>
                    <li><strong>Project only needed fields</strong> to reduce RU consumption</li>
                    <li><strong>Use ORDER BY with caution</strong> - requires composite index for multiple fields</li>
                    <li><strong>Leverage GROUP BY</strong> for analytics within partitions</li>
                    <li><strong>Use ARRAY_CONTAINS</strong> instead of JOIN when possible for better performance</li>
                    <li><strong>Monitor RU consumption</strong> and optimize queries accordingly</li>
                    <li><strong>Test queries</strong> with EXPLAIN for query plan analysis</li>
                </ol>
            </div>

            <h2 id="qd-ru-guidelines">23. RU Cost Guidelines</h2>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Query Type</th>
                        <th>Typical RU Cost</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Point read (by id + partition key)</td>
                        <td>1 RU</td>
                    </tr>
                    <tr>
                        <td>Single partition query</td>
                        <td>3-5 RUs</td>
                    </tr>
                    <tr>
                        <td>Cross-partition query</td>
                        <td>10-50 RUs</td>
                    </tr>
                    <tr>
                        <td>Query with ORDER BY</td>
                        <td>+20-30% RUs</td>
                    </tr>
                    <tr>
                        <td>Query with GROUP BY</td>
                        <td>+30-50% RUs</td>
                    </tr>
                    <tr>
                        <td>Complex joins</td>
                        <td>50+ RUs</td>
                    </tr>
                </tbody>
            </table>

            <p>This document provides a comprehensive overview of test data and SQL API queries for Azure Cosmos DB, covering a wide range of functionalities and best practices to optimize performance and cost.</p>
            </section>

            <section id="cosmosdb-query-performance" role="article">
            
        <h1>Query Performance and Optimization</h1>
        <span class="badge">performance</span>
        <span class="badge">optimization</span>
        <span class="badge">RUs</span>

        <h2>Table of Contents</h2>
        <ol>
            <li><a href="#qp-understanding-partitions">Understanding Partitions</a></li>
            <li><a href="#qp-query-types-costs">Query Types & Costs</a></li>
            <li><a href="#qp-composite-indexes">Composite Indexes</a></li>
            <li><a href="#qp-pagination">Pagination</a></li>
            <li><a href="#qp-hot-partitions">Hot Partitions</a></li>
            <li><a href="#qp-geospatial-queries">Geospatial Queries</a></li>
            <li><a href="#qp-best-practices">Best Practices</a></li>
            <li><a href="#qp-quick-references">Quick Reference</a></li>
            <li><a href="#qp-summary">Summary</a></li>
        </ol>

        <h2 id="qp-understanding-partitions">1. Understanding Partitions</h2>

        <h3>Logical Partitions</h3>
        <ul>
            <li>Data grouped by partition key value</li>
            <li>Isolated for operations and transactions</li>
            <li>Max 20 GB per partition (use Hierarchical Partition Keys to exceed this)</li>
            <li>Scoped to a single partition for best performance</li>
        </ul>

        <h3>Key Concepts</h3>
        <ul>
            <li><strong>Single-Partition Query</strong>: Includes partition key in WHERE clause ‚Üí Low RU cost (~5-20 RU)</li>
            <li><strong>Cross-Partition Query</strong>: No partition key ‚Üí High RU cost (~50-200+ RU), scans all partitions</li>
        </ul>

        <h3>Example</h3>
        <pre><code>-- ‚úÖ Good: Single-partition (fast, cheap)
        SELECT * FROM c WHERE c.userId = 'user-123' AND c.status = 'active'

        -- ‚ùå Avoid: Cross-partition (slow, expensive)
        SELECT * FROM c WHERE c.status = 'active'</code></pre>

        <h2 id="qp-query-types-costs">2. Query Types & Costs</h2>

        <table class="table table-striped">
            <thead>
            <tr>
                <th>Query Pattern</th>
                <th>RU Cost</th>
                <th>Performance</th>
                <th>Use Case</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Point Read (ID + PK)</td>
                <td>1 RU</td>
                <td>‚ö° Instant</td>
                <td>Fetch single item</td>
            </tr>
            <tr>
                <td>Single-Partition Query</td>
                <td>5-20 RU</td>
                <td>‚ö° Fast</td>
                <td>User's orders, device telemetry</td>
            </tr>
            <tr>
                <td>Single-Partition JOIN</td>
                <td>10-40 RU</td>
                <td>üîÑ Good</td>
                <td>Flatten arrays in document</td>
            </tr>
            <tr>
                <td>Cross-Partition Query</td>
                <td>50-200 RU</td>
                <td>üêå Slow</td>
                <td>Admin reports, analytics</td>
            </tr>
            <tr>
                <td>Cross-Partition JOIN</td>
                <td>200-1000+ RU</td>
                <td>üêåüêå Very Slow</td>
                <td>Avoid if possible</td>
            </tr>
            </tbody>
        </table>

        <h3>JOINs in Cosmos DB</h3>
        <ul>
            <li>Only <strong>intra-document</strong> JOINs (flatten arrays within a single document)</li>
            <li>No cross-document or cross-container JOINs</li>
            <li>Always include partition key to avoid expensive cross-partition operations</li>
        </ul>

        <pre><code>-- ‚úÖ Good: Intra-document JOIN with partition key
    SELECT o.orderId, i.productName
    FROM Orders o 
    JOIN i IN o.items
    WHERE o.userId = 'user-123'

    -- ‚ùå Bad: Cross-partition JOIN
    SELECT o.orderId, i.productName
    FROM Orders o 
    JOIN i IN o.items
    -- Missing partition key filter!</code></pre>

        <h2 id="qp-composite-indexes">3. Composite Indexes</h2>

        <h3>When to Use</h3>
        <ul>
            <li>Queries with multiple properties in WHERE clause</li>
            <li>ORDER BY with multiple properties</li>
            <li>Range queries + sorting</li>
        </ul>

        <h3>Performance Impact</h3>
        <ul>
            <li>Without composite index: 100-500+ RU</li>
            <li>With composite index: 10-30 RU (up to 10x faster)</li>
        </ul>

        <h3>Example Configuration</h3>
        <pre><code>{
            "compositeIndexes": [
            [
                {"path": "/category", "order": "ascending"},
                {"path": "/price", "order": "descending"},
                {"path": "/rating", "order": "descending"}
            ]
            ]
        }</code></pre>

        <h3>Example Query</h3>
        <pre><code>SELECT * FROM c 
        WHERE c.category = "Electronics"
        ORDER BY c.price DESC, c.rating DESC</code></pre>

        <h3>Key Rules</h3>
        <ol>
            <li><strong>Property Order Matters</strong>: Index must match query order</li>
            <li><strong>Sort Direction</strong>: Must match ORDER BY direction (or be fully reversed)</li>
            <li><strong>Prefix Principle</strong>: Index supports prefixes: [A], [A,B], [A,B,C]</li>
        </ol>

        <h3>Best Practices</h3>
        <p><strong>‚úÖ Do:</strong></p>
        <ul>
            <li>Analyze query patterns before creating indexes</li>
            <li>Order by selectivity: equality filters ‚Üí ranges ‚Üí ORDER BY</li>
            <li>Test with production data</li>
        </ul>

        <p><strong>‚ùå Don't:</strong></p>
        <ul>
            <li>Over-index (increases write cost)</li>
            <li>Ignore property order</li>
        </ul>

        <h2 id="qp-pagination">4. Pagination</h2>

        <h3>Why Paginate</h3>
        <ul>
            <li>Prevents timeouts and memory issues</li>
            <li>Improves user experience</li>
            <li>Distributes RU cost over time</li>
            <li>Maximum response size is 4MB</li>
        </ul>

        <h3>Continuation Tokens</h3>
        <ul>
            <li>Opaque string representing query position</li>
            <li>Allows resuming from where you left off</li>
            <li>Required for efficient pagination</li>
        </ul>

        <h3>Basic Implementation (.NET)</h3>
        <pre><code>var queryOptions = new QueryRequestOptions
        {
            PartitionKey = new PartitionKey(partitionKey),
            MaxItemCount = 50  // Page size
        };

        var iterator = container.GetItemQueryIterator&lt;T&gt;(
            queryDefinition, 
            continuationToken,  // null for first page
            queryOptions);

        var response = await iterator.ReadNextAsync();

        // Save for next page:
        string nextToken = response.ContinuationToken;
        bool hasMore = !string.IsNullOrEmpty(nextToken);</code></pre>

        <h3>Page Size Recommendations</h3>
        <ul>
            <li>Mobile/Social Feed: 10-20 items</li>
            <li>Desktop Tables: 50-100 items</li>
            <li>Analytics/Export: 500-1000 items</li>
            <li>Search Results: 20-50 items</li>
        </ul>

        <h3>Important Notes</h3>
        <ul>
            <li>Cosmos DB doesn't support OFFSET/SKIP</li>
            <li>Must paginate sequentially (can't jump to page 5 without going through 1-4)</li>
            <li>Cache continuation tokens for visited pages if implementing traditional pagination</li>
        </ul>

        <h2 id="qp-hot-partitions">5. Hot Partitions</h2>

        <h3>What is a Hot Partition?</h3>
        <p>A partition receiving disproportionately more requests than others, causing:</p>
        <ul>
            <li>429 Rate Limit errors</li>
            <li>High latency</li>
            <li>Throttling</li>
            <li>Poor performance</li>
        </ul>

        <h3>Common Causes</h3>

        <p><strong>1. Low Cardinality Partition Keys:</strong></p>
        <pre><code>// ‚ùå BAD: Only 3-5 possible values
        {
            "id": "order-123",
            "status": "active"  // Partition key
        }</code></pre>

        <p><strong>2. Temporal Patterns:</strong></p>
    <ul>
        <li>Monitor "Normalized RU Consumption" metric (alert if &gt; 80%)</li>
        <li>Track 429 error rates</li>
        <li>Check partition key distribution in Azure Portal</li>
    </ul>

    <h3>Mitigation Strategies</h3>

    <p><strong>1. Use Hierarchical Partition Keys (HPK):</strong></p>
    <pre><code>// Container configured with HPK: ["/status", "/customerId"]
    {
        "status": "active",
        "customerId": "customer-456"
    }
    // Distributes "active" across multiple partitions</code></pre>

    <p><strong>2. Synthetic Partition Keys:</strong></p>
    <ul>
        <li>Add randomness: <code>userId-{hash % 100}</code></li>
        <li>Time + randomness: <code>2024120115-{random 0-9}</code></li>
    </ul>

    <p><strong>3. Caching Strategy:</strong></p>
    <ul>
        <li>Cache hot reads in Redis/memory</li>
        <li>Use read replicas for non-critical reads</li>
        <li>Reduce load on hot partition</li>
    </ul>

    <p><strong>4. Partition Key Redesign:</strong></p>
    <ul>
        <li>Choose high-cardinality keys (userId, deviceId, orderId)</li>
        <li>Ensure even distribution</li>
        <li>Plan for future growth</li>
    </ul>

    <h3>Prevention Checklist</h3>
    <p><strong>‚úÖ Do:</strong></p>
    <ul>
        <li>Use high-cardinality partition keys</li>
        <li>Monitor partition distribution regularly</li>
        <li>Load test with realistic data</li>
    </ul>

    <p><strong>‚ùå Don't:</strong></p>
    <ul>
        <li>Use temporal partition keys (dates, hours)</li>
        <li>Use status, country, or category as partition keys</li>
    </ul>

    <h2 id="qp-geospatial-queries">6. Geospatial Queries</h2>

    <h3>Setup</h3>
    <p>Configure spatial indexes in indexing policy:</p>
    <pre><code>{
        "spatialIndexes": [
            {
                "path": "/location/*",
                "types": ["Point"]
            }
        ]
    }</code></pre>

    <h3>Common Functions</h3>

    <p><strong>1. ST_DISTANCE - Find nearby locations:</strong></p>
    <pre><code>SELECT r.id, r.name
    FROM restaurants r
    WHERE r.city = "seattle"  -- Include partition key!
    AND ST_DISTANCE(r.location, @userLocation) &lt; 5000  -- meters</code></pre>

    <p><strong>2. ST_WITHIN - Point-in-polygon:</strong></p>
    <pre><code>SELECT d.name 
    FROM deliveryZones d  
    WHERE ST_WITHIN(@userLocation, d.boundary)</code></pre>

    <h3>Performance</h3>
    <ul>
        <li>With spatial index + partition key: 15-30 RU</li>
        <li>Without spatial index: 200+ RU (full scan)</li>
        <li>Without partition key: 200+ RU (cross-partition scan)</li>
    </ul>

    <h3>Best Practices</h3>
    <p><strong>‚úÖ Do:</strong></p>
    <ul>
        <li>Always configure spatial indexes</li>
        <li>Include partition key in queries (e.g., city, region)</li>
        <li>Limit search radius (&lt; 10km for best performance)</li>
        <li>Use TOP N to limit results</li>
    </ul>

    <p><strong>‚ùå Don't:</strong></p>
    <ul>
        <li>Skip spatial indexing</li>
        <li>Use excessive search radius (&gt; 50km)</li>
    </ul>

    <h2 id="qp-best-practices">7. Best Practices</h2>

    <h3>‚úÖ DO</h3>

    <ol>
        <li><strong>Use Point Reads When Possible</strong>
            <ul><li><code>container.item(id, partitionKey).read()</code> ‚Üí 1 RU</li></ul>
        </li>
        <li><strong>Include Partition Key in Queries</strong>
            <ul>
                <li>Reduces cost by 10-100x</li>
                <li>Improves latency significantly</li>
            </ul>
        </li>
        <li><strong>SELECT Specific Fields</strong>
            <ul>
                <li><code>SELECT c.id, c.name</code> instead of <code>SELECT *</code></li>
                <li>Saves 30-50% RU cost</li>
            </ul>
        </li>
        <li><strong>Implement Pagination</strong>
            <ul>
                <li>Use <code>MaxItemCount</code> and continuation tokens</li>
                <li>Prevents timeouts and memory issues</li>
            </ul>
        </li>
        <li><strong>Denormalize Data</strong>
            <ul>
                <li>Embed related data in single document</li>
                <li>Avoids multiple queries</li>
            </ul>
        </li>
        <li><strong>Optimize Indexes</strong>
            <ul>
                <li>Exclude unused paths from indexing</li>
                <li>Add composite indexes for complex queries</li>
                <li>Monitor index usage</li>
            </ul>
        </li>
    </ol>

    <h3>‚ùå DON'T</h3>

    <ol>
        <li><strong>Query Without Partition Key</strong>
            <ul>
                <li>Causes expensive cross-partition scans</li>
                <li>10-100x more RU cost</li>
            </ul>
        </li>
        <li><strong>Use Cross-Partition JOINs</strong>
            <ul>
                <li>Extremely expensive</li>
                <li>Better to denormalize data</li>
            </ul>
        </li>
        <li><strong>SELECT * Without Filter</strong>
            <ul>
                <li>Full container scan</li>
                <li>Maximum RU cost</li>
            </ul>
        </li>
        <li><strong>Return Large Result Sets</strong>
            <ul>
                <li>Always paginate</li>
                <li>Prevents timeouts</li>
            </ul>
        </li>
        <li><strong>Normalize Like RDBMS</strong>
            <ul>
                <li>Creates need for multiple queries</li>
                <li>Embrace NoSQL denormalization</li>
            </ul>
        </li>
        <li><strong>Use Hot Partition Keys</strong>
            <ul>
                <li>Low cardinality keys (status, country)</li>
                <li>Causes throttling and 429 errors</li>
            </ul>
        </li>
    </ol>

    <h2 id="qp-quick-references">8. Quick References</h2>

    <h3>Optimization Checklist</h3>
    <p><strong>Before Deploying a Query:</strong></p>
    <ul>
        <li>Partition key included in WHERE clause</li>
        <li>Selecting only necessary fields (not SELECT *)</li>
        <li>Result set is paginated (MaxItemCount configured)</li>
        <li>Indexes cover query predicates</li>
        <li>JOINs are intra-document only</li>
        <li>Tested with realistic data volumes</li>
        <li>Request charge measured and acceptable</li>
        <li>Diagnostic logging enabled</li>
    </ul>

    <h3>Query Cost Targets</h3>
    <ul>
        <li>Point Read: ~1 RU</li>
        <li>Simple Query: &lt; 20 RU</li>
        <li>Complex Query: &lt; 50 RU</li>
        <li>Report/Analytics: &lt; 200 RU</li>
    </ul>

    <p><em>If costs exceed these targets, optimize!</em></p>

    <h3>Common Performance Issues</h3>

    <table class="table table-striped">
        <thead>
            <tr>
                <th>Symptom</th>
                <th>Likely Cause</th>
                <th>Solution</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>High RU cost</td>
                <td>No partition key in WHERE</td>
                <td>Add partition key filter</td>
            </tr>
            <tr>
                <td>429 errors</td>
                <td>Hot partition</td>
                <td>Redesign partition key</td>
            </tr>
            <tr>
                <td>Slow queries</td>
                <td>Missing indexes</td>
                <td>Add composite indexes</td>
            </tr>
            <tr>
                <td>Timeouts</td>
                <td>Large result set</td>
                <td>Implement pagination</td>
            </tr>
            <tr>
                <td>High latency</td>
                <td>Cross-partition query</td>
                <td>Include partition key</td>
            </tr>
        </tbody>
    </table>

    <h3>Monitoring Metrics</h3>

    <p><strong>Track These:</strong></p>
    <ul>
        <li>Request Charge (RU) per query</li>
        <li>Normalized RU Consumption per partition</li>
        <li>429 rate limit errors</li>
        <li>Query latency (P50, P95, P99)</li>
        <li>Index hit ratio (target &gt; 95%)</li>
    </ul>

    <p><strong>Alert When:</strong></p>
    <ul>
        <li>Single query &gt; 100 RU (investigate optimization)</li>
        <li>Partition consumption &gt; 80% (hot partition risk)</li>
        <li>429 error rate &gt; 5% (immediate action needed)</li>
        <li>P95 latency &gt; 100ms (performance degradation)</li>
    </ul>

    <h2 id="qp-summary">9. Summary</h2>

    <div class="callout">
        <p><strong>Remember:</strong></p>
        <ol>
            <li><strong>Partition key is critical</strong> - Include it in every query for best performance</li>
            <li><strong>Cross-partition queries are expensive</strong> - Avoid when possible (10x-100x more RU)</li>
            <li><strong>JOINs work differently</strong> - Only intra-document array flattening</li>
            <li><strong>Denormalization is key</strong> - Embrace NoSQL patterns</li>
            <li><strong>Always paginate</strong> - Control result set size</li>
            <li><strong>Select specific fields</strong> - Reduces RU and network overhead</li>
            <li><strong>Monitor and optimize</strong> - Track RU consumption and diagnostics</li>
        </ol>
    </div>

    <h3>Cost Comparison Summary</h3>

    <table class="table table-striped">
        <thead>
            <tr>
                <th>Query Pattern</th>
                <th>RU Cost</th>
                <th>Performance</th>
                <th>Recommended</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Point Read (ID + PK)</td>
                <td>1 RU</td>
                <td>‚ö° Instant</td>
                <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
            </tr>
            <tr>
                <td>Single-Partition Query</td>
                <td>5-20 RU</td>
                <td>‚ö° Fast</td>
                <td>‚≠ê‚≠ê‚≠ê‚≠ê</td>
            </tr>
            <tr>
                <td>Single-Partition JOIN</td>
                <td>10-40 RU</td>
                <td>üîÑ Good</td>
                <td>‚≠ê‚≠ê‚≠ê</td>
            </tr>
            <tr>
                <td>Cross-Partition Query</td>
                <td>50-200 RU</td>
                <td>üêå Slow</td>
                <td>‚≠ê‚≠ê</td>
            </tr>
            <tr>
                <td>Cross-Partition JOIN</td>
                <td>200-1000+ RU</td>
                <td>üêåüêå Very Slow</td>
                <td>‚≠ê</td>
            </tr>
        </tbody>
    </table>

    <p><strong>Always strive for single-partition queries with specific field selection and pagination!</strong></p>
            </section>

            <section id="cosmosdb-server-side-programming" role="article">
                <h1>Server-Side Programming</h1>
                <span class="badge">stored-procedures</span>
                <span class="badge">triggers</span>
                <span class="badge">UDFs</span>

                <h2>Table of Contents</h2>
                <ol>
                    <li><a href="#ssp-overview">Overview</a></li>
                    <li><a href="#ssp-stored-procedures">Stored Procedures</a></li>
                    <li><a href="#ssp-triggers">Triggers</a></li>
                    <li><a href="#ssp-udfs">User-Defined Functions (UDFs)</a></li>
                    <li><a href="#ssp-change-feed">Change Feed</a></li>
                    <li><a href="#ssp-best-practices">Best Practices</a></li>
                    <li><a href="#ssp-summary">Summary</a></li>
                </ol>

                <h2 id="ssp-overview">1. Overview</h2>

                <p>Azure Cosmos DB supports <strong>JavaScript-based server-side programming</strong> for transactional operations within a single logical partition. Unlike traditional SQL databases, Cosmos DB does not support views, but offers Change Feed as a powerful alternative.</p>

                <h3>Supported Features</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Purpose</th>
                            <th>Scope</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>üìù Stored Procedures</strong></td>
                            <td>Complex transactional operations, batch processing</td>
                            <td>Single partition</td>
                        </tr>
                        <tr>
                            <td><strong>‚ö° Triggers</strong></td>
                            <td>Pre/post write operations, validation, auditing</td>
                            <td>Single partition</td>
                        </tr>
                        <tr>
                            <td><strong>üîß UDFs</strong></td>
                            <td>Custom functions in queries, reusable calculations</td>
                            <td>Query context</td>
                        </tr>
                    </tbody>
                </table>

                <h3>NOT Supported</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Why Not</th>
                            <th>Alternative</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>üìä Traditional Views</strong></td>
                            <td>Not available in NoSQL model</td>
                            <td>Use Change Feed for materialized views</td>
                        </tr>
                        <tr>
                            <td><strong>üîÑ Cross-Partition UDFs</strong></td>
                            <td>Single partition design</td>
                            <td>Use client-side logic or Change Feed processors</td>
                        </tr>
                        <tr>
                            <td><strong>‚öôÔ∏è Scheduled Jobs</strong></td>
                            <td>No built-in scheduler</td>
                            <td>Use Azure Functions with timer triggers</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Key Characteristics</h3>

                <ul>
                    <li><strong>Language</strong>: JavaScript (ECMAScript 5)</li>
                    <li><strong>Scope</strong>: Single logical partition only</li>
                    <li><strong>Transactions</strong>: ACID guarantees within partition</li>
                    <li><strong>Execution</strong>: Server-side, reducing network round-trips</li>
                    <li><strong>Timeout</strong>: 5 seconds default (configurable up to 60s via request options)</li>
                </ul>

                <div class="callout">
                    <p><strong>‚è±Ô∏è Execution Time Limits</strong></p>
                    <p>All server-side JavaScript code (stored procedures, triggers, UDFs) is subject to strict execution time limits:</p>
                    <ul>
                        <li><strong>Default timeout:</strong> 5 seconds</li>
                        <li><strong>Maximum timeout:</strong> 60 seconds (configurable via SDK request options)</li>
                        <li><strong>Why:</strong> Prevents long-running operations from blocking resources</li>
                        <li><strong>Best practice:</strong> Use continuation tokens for batch operations that may exceed limits</li>
                        <li><strong>If exceeded:</strong> Operation fails with timeout error; partial work may be rolled back</li>
                    </ul>
                    <p>Design your stored procedures to complete quickly or implement continuation logic for large batch operations.</p>
                </div>

                <h2>2. Stored Procedures</h2>

                <p>Stored procedures enable complex, transactional operations that execute atomically on the server.</p>

                <h3>When to Use</h3>

                <p><strong>‚úÖ Good Use Cases:</strong></p>
                <ul>
                    <li>Batch creating/updating multiple documents</li>
                    <li>Atomic counter increments</li>
                    <li>Complex business logic within a partition</li>
                    <li>Reducing network round-trips for multi-step operations</li>
                    <li>Ensuring transactional consistency</li>
                </ul>

                <p><strong>‚ùå Avoid For:</strong></p>
                <ul>
                    <li>Long-running operations (&gt;5 seconds)</li>
                    <li>Cross-partition operations</li>
                    <li>Operations requiring external API calls</li>
                    <li>Simple single-document operations</li>
                </ul>

                <h3>Key Features</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Transactional</strong></td>
                            <td>All operations succeed or fail together (ACID)</td>
                        </tr>
                        <tr>
                            <td><strong>Continuation Tokens</strong></td>
                            <td>Handle large batch operations across multiple executions</td>
                        </tr>
                        <tr>
                            <td><strong>Server-Side Execution</strong></td>
                            <td>Reduces latency and network traffic</td>
                        </tr>
                        <tr>
                            <td><strong>JavaScript Context</strong></td>
                            <td>Access to <code>getContext()</code>, collection, request, response objects</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Patterns</h3>

                <ol>
                    <li><strong>Bulk Import</strong>: Insert multiple documents in a single transaction</li>
                    <li><strong>Counter Increment</strong>: Atomically update counters without race conditions</li>
                    <li><strong>Conditional Updates</strong>: Check conditions before updating</li>
                    <li><strong>Batch Processing</strong>: Process related documents together</li>
                </ol>

                <h2>3. Triggers</h2>

                <p>Triggers execute automatically before (pre-trigger) or after (post-trigger) document operations.</p>

                <h3>Pre-Triggers</h3>

                <p><strong>Execute Before</strong>: Create, Replace, Delete operations</p>

                <p><strong>Common Uses:</strong></p>
                <ul>
                    <li>‚úÖ Data validation (check required fields, formats)</li>
                    <li>‚úÖ Auto-timestamping (add <code>createdAt</code>, <code>modifiedAt</code>)</li>
                    <li>‚úÖ Data normalization (standardize formats)</li>
                    <li>‚úÖ Compute derived fields</li>
                    <li>‚úÖ Enforce business rules</li>
                </ul>

                <p><strong>Characteristics:</strong></p>
                <ul>
                    <li>Must be explicitly requested in each operation</li>
                    <li>Can modify the document being written</li>
                    <li>Failures abort the operation</li>
                    <li>Added to write operation RU cost (+2-5 RU)</li>
                </ul>

                <h3>Post-Triggers</h3>

                <p><strong>Execute After</strong>: Create, Replace, Delete operations (on success)</p>

                <p><strong>Common Uses:</strong></p>
                <ul>
                    <li>‚úÖ Audit logging</li>
                    <li>‚úÖ Update related documents in same partition</li>
                    <li>‚úÖ Send notifications (within same container)</li>
                    <li>‚úÖ Maintain aggregate values</li>
                    <li>‚úÖ Cascade updates</li>
                </ul>

                <p><strong>Characteristics:</strong></p>
                <ul>
                    <li>Execute within the same transaction</li>
                    <li>Cannot modify the original document</li>
                    <li>Failures rollback the entire operation</li>
                    <li>Added to write operation RU cost (+2-5 RU)</li>
                </ul>

                <h3>Pre vs Post Triggers</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Pre-Trigger</th>
                            <th>Post-Trigger</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Timing</strong></td>
                            <td>Before write</td>
                            <td>After write (before commit)</td>
                        </tr>
                        <tr>
                            <td><strong>Modify Document</strong></td>
                            <td>‚úÖ Yes</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td><strong>Validation</strong></td>
                            <td>‚úÖ Ideal</td>
                            <td>‚ö†Ô∏è Less common</td>
                        </tr>
                        <tr>
                            <td><strong>Audit Logging</strong></td>
                            <td>‚ö†Ô∏è Possible</td>
                            <td>‚úÖ Ideal</td>
                        </tr>
                        <tr>
                            <td><strong>Failure Impact</strong></td>
                            <td>Aborts operation</td>
                            <td>Rolls back operation</td>
                        </tr>
                    </tbody>
                </table>

                <h2 id="ssp-udfs">4. User-Defined Functions (UDFs)</h2>

                <p>UDFs are custom JavaScript functions used within SQL queries for calculations and transformations.</p>

                <h3>When to Use</h3>

                <p><strong>‚úÖ Good Use Cases:</strong></p>
                <ul>
                    <li>Custom calculations in SELECT clause</li>
                    <li>Complex filtering logic in WHERE clause</li>
                    <li>Reusable business logic across queries</li>
                    <li>Data transformations and formatting</li>
                    <li>String manipulations, date calculations</li>
                </ul>

                <p><strong>‚ùå Avoid For:</strong></p>
                <ul>
                    <li>Cross-document logic (UDFs work on single documents)</li>
                    <li>Heavy computation (impacts query performance)</li>
                    <li>Operations better done client-side</li>
                    <li>Logic that changes frequently</li>
                </ul>

                <h3>Characteristics</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Detail</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Query context, single partition</td>
                        </tr>
                        <tr>
                            <td><strong>Usage</strong></td>
                            <td>SELECT, WHERE, ORDER BY clauses</td>
                        </tr>
                        <tr>
                            <td><strong>RU Cost</strong></td>
                            <td>+1-3 RU per result row</td>
                        </tr>
                        <tr>
                            <td><strong>Execution</strong></td>
                            <td>Evaluated for each document in result set</td>
                        </tr>
                        <tr>
                            <td><strong>Return Type</strong></td>
                            <td>Scalar values (numbers, strings, booleans, objects)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Patterns</h3>

                <ol>
                    <li><strong>Tax Calculation</strong>: <code>udf.calculateTax(price, taxRate)</code></li>
                    <li><strong>Date Formatting</strong>: <code>udf.formatDate(timestamp, format)</code></li>
                    <li><strong>String Operations</strong>: <code>udf.fullName(firstName, lastName)</code></li>
                    <li><strong>Business Rules</strong>: <code>udf.isEligible(customer)</code></li>
                    <li><strong>Distance Calculation</strong>: <code>udf.distance(lat1, lon1, lat2, lon2)</code></li>
                </ol>

                <h2 id="ssp-change-feed">5. Change Feed</h2>

                <p>Change Feed is a <strong>persistent, ordered log of all changes</strong> (creates, updates, deletes) made to documents in a Cosmos DB container. It enables real-time event-driven architectures.</p>

                <p><strong>What Gets Captured:</strong></p>
                <ul>
                    <li>‚úÖ <strong>Creates</strong>: New documents added</li>
                    <li>‚úÖ <strong>Updates</strong>: Modifications to existing documents</li>
                    <li>‚úÖ <strong>Deletes</strong>: Document removals (All Versions mode only)</li>
                </ul>

                <p><strong>Why Use It:</strong></p>
                <ul>
                    <li>Build materialized views</li>
                    <li>Send real-time notifications</li>
                    <li>Sync data to external systems</li>
                    <li>Implement event-driven workflows</li>
                    <li>Create audit trails</li>
                </ul>

                <h3>Key Concepts</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>üìã Ordered</strong></td>
                            <td>Changes within each partition key are ordered. Cross-partition order varies.</td>
                        </tr>
                        <tr>
                            <td><strong>‚ôæÔ∏è Persistent</strong></td>
                            <td>Changes never expire and are available until processed. No retention limits.</td>
                        </tr>
                        <tr>
                            <td><strong>‚ö° Real-Time</strong></td>
                            <td>Near real-time delivery with typically &lt; 1 second latency</td>
                        </tr>
                        <tr>
                            <td><strong>üîÑ At-Least-Once</strong></td>
                            <td>Guaranteed delivery, but may receive duplicates. Idempotency required.</td>
                        </tr>
                        <tr>
                            <td><strong>üìç Lease Management</strong></td>
                            <td>Uses checkpoint container to track progress and enable scale-out</td>
                        </tr>
                        <tr>
                            <td><strong>üí∞ Low Cost</strong></td>
                            <td>1-2 RU per batch read. No additional storage costs.</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Change Feed Modes</h3>

                <h4>Latest Version Mode (Default)</h4>

                <p><strong>Captures:</strong> Only the most recent version of each document</p>

                <p><strong>Characteristics:</strong></p>
                <ul>
                    <li>Lower storage and processing costs</li>
                    <li>Suitable for most scenarios</li>
                    <li>Cannot track intermediate changes</li>
                    <li>No delete notifications</li>
                </ul>

                <p><strong>Best for:</strong> Materialized views, cache invalidation, current state notifications</p>

                <h4>All Versions and Deletes Mode</h4>

                <p><strong>Captures:</strong> All document versions plus delete events</p>

                <p><strong>Characteristics:</strong></p>
                <ul>
                    <li>Captures complete history of changes</li>
                    <li>Delete notifications included</li>
                    <li>Higher storage costs</li>
                    <li>Requires retention policy (configurable: minimum 4 minutes up to 7 days or longer based on your requirements, set at container level)</li>
                </ul>

                <p><strong>Best for:</strong> Audit trails, event sourcing, compliance requirements</p>

                <h4>Comparison</h4>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Latest Version</th>
                            <th>All Versions &amp; Deletes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Creates</strong></td>
                            <td>‚úÖ</td>
                            <td>‚úÖ</td>
                        </tr>
                        <tr>
                            <td><strong>Updates</strong></td>
                            <td>‚úÖ (latest only)</td>
                            <td>‚úÖ (all versions)</td>
                        </tr>
                        <tr>
                            <td><strong>Deletes</strong></td>
                            <td>‚ùå</td>
                            <td>‚úÖ</td>
                        </tr>
                        <tr>
                            <td><strong>Storage Cost</strong></td>
                            <td>Low</td>
                            <td>Higher</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case</strong></td>
                            <td>Materialized views</td>
                            <td>Audit trails</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Processing Options</h3>

                <h4>Option 1: Azure Functions (Recommended)</h4>
                <p><strong>Best for:</strong> Most scenarios requiring serverless, auto-scaling solutions</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Serverless, auto-scaling</li>
                    <li>‚úÖ Simple configuration with triggers</li>
                    <li>‚úÖ Built-in retry logic</li>
                    <li>‚úÖ Easy monitoring via Application Insights</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ö†Ô∏è Cold start latency possible</li>
                    <li>‚ö†Ô∏è 10-minute execution timeout</li>
                </ul>

                <h4>Option 2: Change Feed Processor SDK</h4>
                <p><strong>Best for:</strong> Fine-grained control in custom applications</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Full control over processing logic</li>
                    <li>‚úÖ Custom error handling</li>
                    <li>‚úÖ Advanced configuration options</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ö†Ô∏è More complex setup</li>
                    <li>‚ö†Ô∏è Need to manage host infrastructure</li>
                </ul>

                <h4>Option 3: Pull Model</h4>
                <p><strong>Best for:</strong> Batch processing or specific time ranges</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Complete control over polling</li>
                    <li>‚úÖ Can start from specific time</li>
                    <li>‚úÖ Good for one-time migrations</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ö†Ô∏è Manual checkpoint management</li>
                    <li>‚ö†Ô∏è No automatic scaling</li>
                </ul>

                <h3>Common Use Cases</h3>

                <h4>1. Materialized Views (Primary Use Case)</h4>
                <p><strong>Problem:</strong> Complex queries are expensive<br>
                <strong>Solution:</strong> Pre-aggregate data into read-optimized containers<br>
                <strong>Example:</strong> Customer order summaries from individual orders</p>

                <p><strong>How It Works:</strong></p>
                <ol>
                    <li>Source container receives writes</li>
                    <li>Change Feed captures all changes</li>
                    <li>Processor (Azure Function) aggregates/transforms data</li>
                    <li>Results written to target container (materialized view)</li>
                    <li>Applications query the materialized view (fast &amp; cheap)</li>
                </ol>

                <p><strong>Benefits:</strong></p>
                <ul>
                    <li>üöÄ Fast reads (1-2 RU vs 50+ RU)</li>
                    <li>üí∞ Lower query costs</li>
                    <li>üìä Real-time updates</li>
                </ul>

                <h4>Benefits vs Traditional Views</h4>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Traditional Views</th>
                            <th>Change Feed Materialized Views</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Query Speed</strong></td>
                            <td>Slow (computed each time)</td>
                            <td>Fast (pre-computed)</td>
                        </tr>
                        <tr>
                            <td><strong>RU Cost</strong></td>
                            <td>High (50-100+ RU)</td>
                            <td>Low (1-2 RU)</td>
                        </tr>
                        <tr>
                            <td><strong>Freshness</strong></td>
                            <td>Always current</td>
                            <td>Near real-time (&lt; 1 sec)</td>
                        </tr>
                        <tr>
                            <td><strong>Scalability</strong></td>
                            <td>Limited</td>
                            <td>Excellent</td>
                        </tr>
                        <tr>
                            <td><strong>Complexity</strong></td>
                            <td>Simple</td>
                            <td>Moderate (needs processor)</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>Example Scenarios:</strong></p>

                <p><strong>üìù Note on "Materialized Views":</strong> In Cosmos DB, a "materialized view" refers to a <strong>separate target container</strong> where you store pre-computed, aggregated, or transformed data. Unlike traditional database views (which are virtual), these are <strong>physical collections</strong> of documents that you create and maintain using Change Feed processors. Think of them as "pre-computed result tables" optimized for specific read patterns.</p>

                <p><strong>Customer Order Summary</strong></p>
                <ul>
                    <li>Source: Orders container (normalized)</li>
                    <li>Change Feed: Processes each order</li>
                    <li>Target: CustomerSummary container (denormalized) ‚Äî this is the "materialized view"</li>
                    <li>Benefit: Fast customer dashboards without expensive aggregations</li>
                </ul>

                <p><strong>Product Inventory Dashboard</strong></p>
                <ul>
                    <li>Source: Transactions container</li>
                    <li>Change Feed: Aggregates stock levels</li>
                    <li>Target: InventoryView container</li>
                    <li>Benefit: Real-time inventory without expensive queries</li>
                </ul>

                <p><strong>Analytics Aggregations</strong></p>
                <ul>
                    <li>Source: Events container</li>
                    <li>Change Feed: Compute metrics</li>
                    <li>Target: Metrics container</li>
                    <li>Benefit: Pre-computed analytics for dashboards</li>
                </ul>

                <h4>2. Event Notifications</h4>
                <p><strong>Problem:</strong> Need to notify users of data changes<br>
                <strong>Solution:</strong> Process changes and send notifications<br>
                <strong>Example:</strong> Order status updates, inventory alerts</p>

                <h4>3. Data Synchronization</h4>
                <p><strong>Problem:</strong> Keep multiple systems in sync<br>
                <strong>Solution:</strong> Stream changes to external systems<br>
                <strong>Example:</strong> Update search indexes, refresh caches, sync to data lake</p>

                <h4>4. Real-Time Analytics</h4>
                <p><strong>Problem:</strong> Need live dashboards<br>
                <strong>Solution:</strong> Stream changes to analytics engines<br>
                <strong>Example:</strong> Live sales metrics, user activity tracking</p>

                <h4>5. Audit &amp; Compliance</h4>
                <p><strong>Problem:</strong> Track all data modifications<br>
                <strong>Solution:</strong> Use All Versions mode to capture complete history<br>
                <strong>Example:</strong> Financial audit trails, regulatory compliance</p>

                <h4>6. Event-Driven Microservices</h4>
                <p><strong>Problem:</strong> Services need to react to data changes<br>
                <strong>Solution:</strong> Use Change Feed as event backbone<br>
                <strong>Example:</strong> Order processing workflows, saga patterns</p>

                <h3>Change Feed Cost Considerations</h3>

                <h4>RU Consumption</h4>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>RU Cost</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Read Changes (batch)</strong></td>
                            <td>1-2 RU</td>
                            <td>Very efficient per batch</td>
                        </tr>
                        <tr>
                            <td><strong>Lease Operations</strong></td>
                            <td>5-10 RU</td>
                            <td>Checkpoint operations</td>
                        </tr>
                        <tr>
                            <td><strong>Empty Poll</strong></td>
                            <td>1 RU</td>
                            <td>When no changes, minimal cost</td>
                        </tr>
                        <tr>
                            <td><strong>1000 Documents</strong></td>
                            <td>~10 RU</td>
                            <td>Plus downstream processing</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Optimization Tips</h4>

                <ol>
                    <li><strong>Increase Batch Size</strong> - Process more items per batch to reduce per-document RU cost</li>
                    <li><strong>Reduce Polling Frequency</strong> - Adjust poll interval based on latency requirements</li>
                    <li><strong>Filter Early</strong> - Skip irrelevant changes to reduce processing costs</li>
                    <li><strong>Right-Size Lease Container</strong> - 400 RU/s is typically sufficient</li>
                    <li><strong>Monitor &amp; Adjust</strong> - Track RU consumption and optimize based on patterns</li>
                </ol>

                <h4>Typical Monthly Costs</h4>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Volume</th>
                            <th>Documents/Day</th>
                            <th>Est. RU/s</th>
                            <th>Monthly Cost*</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Low</strong></td>
                            <td>10K</td>
                            <td>100</td>
                            <td>~$6</td>
                        </tr>
                        <tr>
                            <td><strong>Medium</strong></td>
                            <td>100K</td>
                            <td>500</td>
                            <td>~$30</td>
                        </tr>
                        <tr>
                            <td><strong>High</strong></td>
                            <td>1M</td>
                            <td>2,000</td>
                            <td>~$120</td>
                        </tr>
                        <tr>
                            <td><strong>Very High</strong></td>
                            <td>10M</td>
                            <td>10,000</td>
                            <td>~$600</td>
                        </tr>
                    </tbody>
                </table>

                <p><em>*Change Feed processing only, excludes downstream operations</em></p>

                <h2 id="ssp-best-practices">6. Best Practices</h2>

                <h3>‚úÖ DO's and ‚ùå DON'Ts</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>‚úÖ Pros (DO's)</th>
                            <th>‚ùå Cons (DON'Ts)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Stored Procedures</strong></td>
                            <td>
                                <ul>
                                    <li>Keep operations under 5 seconds</li>
                                    <li>Use continuation tokens for large batches</li>
                                    <li>Handle errors and rollback appropriately</li>
                                    <li>Test with realistic data volumes</li>
                                    <li>Include partition key in all operations</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Don't use for long-running operations</li>
                                    <li>Don't perform unbounded loops</li>
                                    <li>Don't ignore continuation tokens</li>
                                    <li>Don't use for cross-partition operations</li>
                                    <li>Don't include external API calls</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Triggers</strong></td>
                            <td>
                                <ul>
                                    <li>Keep logic minimal and fast</li>
                                    <li>Explicitly request triggers in operations</li>
                                    <li>Use pre-triggers for validation</li>
                                    <li>Use post-triggers for audit logging</li>
                                    <li>Handle errors gracefully</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Don't use for heavy computation</li>
                                    <li>Don't assume triggers always execute (must request)</li>
                                    <li>Don't use post-triggers for critical updates</li>
                                    <li>Don't use external JavaScript libraries</li>
                                    <li>Don't ignore timeout limits</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>User-Defined Functions (UDFs)</strong></td>
                            <td>
                                <ul>
                                    <li>Keep functions simple and fast</li>
                                    <li>Avoid complex computations</li>
                                    <li>Test performance impact on queries</li>
                                    <li>Use for reusable query logic</li>
                                    <li>Document function purpose and usage</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Don't use for cross-document logic</li>
                                    <li>Don't perform expensive calculations</li>
                                    <li>Don't modify state or have side effects</li>
                                    <li>Don't ignore RU consumption</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Change Feed</strong></td>
                            <td>
                                <ul>
                                    <li>Use dedicated lease container for checkpoints</li>
                                    <li>Implement idempotency to handle duplicate deliveries</li>
                                    <li>Process in batches (100-1000 items) for efficiency</li>
                                    <li>Monitor lag and performance regularly</li>
                                    <li>Handle errors gracefully with retry logic</li>
                                    <li>Scale horizontally by adding processor instances</li>
                                    <li>Identify expensive query patterns for materialized views</li>
                                    <li>Design target schema optimized for read patterns</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Don't block processing with long-running operations</li>
                                    <li>Don't ignore errors or silently swallow failures</li>
                                    <li>Don't share lease containers between processors</li>
                                    <li>Don't skip checkpoints (prevents recovery)</li>
                                    <li>Don't assume cross-partition ordering</li>
                                </ul>
                            </td>
                        </tr>
                    </tbody>
                </table>

                <h3>Performance Tips</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>RU Impact</th>
                            <th>Optimization</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Stored Procedure (single doc)</strong></td>
                            <td>5-10 RU</td>
                            <td>Batch multiple docs together</td>
                        </tr>
                        <tr>
                            <td><strong>Stored Procedure (batch 10 docs)</strong></td>
                            <td>15-30 RU</td>
                            <td>More efficient than individual ops</td>
                        </tr>
                        <tr>
                            <td><strong>Pre-Trigger</strong></td>
                            <td>+2-5 RU per write</td>
                            <td>Keep logic minimal</td>
                        </tr>
                        <tr>
                            <td><strong>Post-Trigger</strong></td>
                            <td>+2-5 RU per write</td>
                            <td>Consider async alternatives</td>
                        </tr>
                        <tr>
                            <td><strong>UDF in Query</strong></td>
                            <td>+1-3 RU per row</td>
                            <td>Minimize usage, optimize logic</td>
                        </tr>
                    </tbody>
                </table>

                <h2 id="ssp-summary">7. Summary</h2>

                <h3>Feature Comparison</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Use For</th>
                            <th>Scope</th>
                            <th>RU Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Stored Procedures</strong></td>
                            <td>Batch operations, atomic transactions</td>
                            <td>Single partition</td>
                            <td>5-30 RU</td>
                        </tr>
                        <tr>
                            <td><strong>Pre-Triggers</strong></td>
                            <td>Validation, auto-timestamps</td>
                            <td>Single partition</td>
                            <td>+2-5 RU</td>
                        </tr>
                        <tr>
                            <td><strong>Post-Triggers</strong></td>
                            <td>Audit, cascade updates</td>
                            <td>Single partition</td>
                            <td>+2-5 RU</td>
                        </tr>
                        <tr>
                            <td><strong>UDFs</strong></td>
                            <td>Query calculations</td>
                            <td>Query context</td>
                            <td>+1-3 RU/row</td>
                        </tr>
                        <tr>
                            <td><strong>Change Feed</strong></td>
                            <td>Materialized views, events</td>
                            <td>Container-wide</td>
                            <td>1-2 RU/batch</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to Use What</h3>

                <p><strong>Stored Procedures</strong> ‚Üí Transactional batch operations within partition<br>
                <strong>Pre-Triggers</strong> ‚Üí Data validation before write<br>
                <strong>Post-Triggers</strong> ‚Üí Audit logging after write<br>
                <strong>UDFs</strong> ‚Üí Custom calculations in queries<br>
                <strong>Change Feed</strong> ‚Üí Materialized views and event-driven patterns</p>

                <h3>Key Takeaways</h3>

                <div class="callout">
                    <ol>
                        <li><strong>No Traditional Views</strong> - Use Change Feed to build materialized views</li>
                        <li><strong>Single Partition Scope</strong> - All server-side code (sprocs, triggers, UDFs) operates within a partition</li>
                        <li><strong>JavaScript Only</strong> - ECMAScript 5 syntax, no external libraries</li>
                        <li><strong>5-Second Timeout</strong> - Keep stored procedures, triggers, and UDFs short and efficient</li>
                        <li><strong>Change Feed Container-Wide</strong> - Captures all changes across all partitions</li>
                        <li><strong>Two Change Feed Modes</strong> - Latest Version (default) vs All Versions &amp; Deletes</li>
                        <li><strong>ACID Transactions</strong> - Guaranteed within partition boundaries for sprocs and triggers</li>
                        <li><strong>Explicit Triggers</strong> - Must be requested in each operation</li>
                        <li><strong>Idempotency Required</strong> - Change Feed has at-least-once delivery</li>
                        <li><strong>Monitor RU Costs</strong> - All server-side operations consume RUs</li>
                    </ol>
                </div>

                <h2>Additional Resources</h2>

                <ul class="list-style-none">
                    <li><a href="https://learn.microsoft.com/azure/cosmos-db/sql/how-to-write-stored-procedures-triggers-udfs" target="_blank">Stored Procedures, Triggers, and UDFs Documentation</a></li>
                    <li><a href="https://learn.microsoft.com/azure/cosmos-db/change-feed" target="_blank">Change Feed Overview</a></li>
                    <li><a href="https://learn.microsoft.com/azure/azure-functions/functions-bindings-cosmosdb-v2-trigger" target="_blank">Azure Functions Cosmos DB Trigger</a></li>
                    <li><a href="https://learn.microsoft.com/azure/cosmos-db/sql/change-feed-design-patterns" target="_blank">Change Feed Design Patterns</a></li>
                    <li><a href="https://github.com/Azure/azure-cosmosdb-js-server" target="_blank">Server-Side Programming Samples</a></li>
                </ul>

            </section>

            <section id="cosmosdb-vector-search" role="article">
                <h1>Vector Search and AI Integration</h1>
                <span class="badge">AI</span>
                <span class="badge">vector-search</span>
                <span class="badge">embeddings</span>
                <span class="badge">RAG</span>

                <h2>Table of Contents</h2>
                <ol>
                    <li><a href="#vector-search-overview">Overview</a></li>
                    <li><a href="#what-is-vector-search">What is Vector Search?</a></li>
                    <li><a href="#vs-use-cases">Use Cases</a></li>
                    <li><a href="#vs-how-it-works">How It Works</a></li>
                    <li><a href="#vector-search-vs-alternatives">Vector Search vs Alternatives</a></li>
                    <li><a href="#vs-integration-benefits">Integration Benefits</a></li>
                    <li><a href="#vector-search-best-practices">Best Practices</a></li>
                    <li><a href="#vector-search-summary">Summary</a></li>
                </ol>

                <h2 id="vector-search-overview">Overview</h2>

                <p>Azure Cosmos DB for NoSQL provides <strong>integrated vector search capabilities</strong>, enabling you to store, index, and query high-dimensional vectors alongside your operational data. This makes Cosmos DB an excellent choice for AI-powered applications that require both transactional data management and semantic search capabilities.</p>

                <div class="callout">
                    <p><strong>üöÄ Why Vector Search in Cosmos DB?</strong></p>
                    <ul>
                        <li><strong>Unified Database</strong>: Store vectors and application data together‚Äîno separate vector database needed</li>
                        <li><strong>Low Cost</strong>: More cost-effective than dedicated vector databases for most workloads</li>
                        <li><strong>Global Distribution</strong>: Vectors replicate across regions automatically</li>
                        <li><strong>Scalable</strong>: Handles billions of vectors with horizontal scaling</li>
                        <li><strong>Fast</strong>: Low-latency vector similarity search (&lt; 10ms)</li>
                    </ul>
                </div>

                <h2 id="what-is-vector-search">What is Vector Search?</h2>

                <p><strong>Vector search</strong> (also called <em>similarity search</em> or <em>semantic search</em>) allows you to find items based on <strong>meaning</strong> rather than exact keyword matches. It works by converting text, images, or other content into high-dimensional numerical vectors (embeddings) using AI models.</p>

                <h3>Traditional Search vs Vector Search</h3>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI'}, 'flowchart': {'nodeSpacing': 30, 'rankSpacing': 50}}}%%
                flowchart LR
                    subgraph Traditional["‚ùå Traditional Keyword Search"]
                        T1["Query: 
                'dog'"]
                        T2["Matches: 
                Documents with 
                exact word 'dog'"]
                        T3["Misses: 
                'puppy', 'canine', 
                'pet'"]
                        T1 --> T2
                        T2 --> T3
                        style T1 fill:#fcc,stroke:#333
                        style T2 fill:#ffc,stroke:#333
                        style T3 fill:#ccc,stroke:#333
                    end

                    subgraph Vector["‚úÖ Vector Semantic Search"]
                        V1["Query: 
                'dog'"]
                        V2["Convert to 
                Vector Embedding 
                [0.2, 0.7, ...]"]
                        V3["Find Similar: 
                'puppy', 'canine', 
                'pet', 'dog'"]
                        V1 --> V2
                        V2 --> V3
                        style V1 fill:#cfc,stroke:#333
                        style V2 fill:#9f9,stroke:#333
                        style V3 fill:#6f6,stroke:#333
                    end
                </div>

                <h3>How Embeddings Work</h3>

                <p>AI models (like OpenAI's <code>text-embedding-ada-002</code>, Azure OpenAI, or open-source models) convert text into dense numerical vectors:</p>

                <pre><code>Text: "Azure Cosmos DB is a globally distributed database"
    ‚Üì (AI Model)
    Vector: [0.12, -0.34, 0.89, 0.45, ..., 0.67]  // 1536 dimensions</code></pre>

                <p>Semantically similar text produces vectors that are <strong>close together</strong> in the vector space, enabling similarity-based search.</p>

                <h2 id="vs-use-cases">Use Cases</h2>

                <h3>ü§ñ AI and Chat Applications</h3>

                <p><strong>1. Chat History with Semantic Search</strong></p>
                <ul>
                    <li>Store conversation messages with vector embeddings</li>
                    <li>Retrieve relevant past conversations based on meaning</li>
                    <li>Build contextual AI assistants with long-term memory</li>
                </ul>

                <p><strong>2. Retrieval-Augmented Generation (RAG)</strong></p>
                <ul>
                    <li>Store knowledge base documents with embeddings</li>
                    <li>Retrieve relevant context for AI model prompts</li>
                    <li>Ground AI responses in your own data</li>
                    <li><strong>Example</strong>: Customer support chatbot that references company documentation</li>
                </ul>

                <p><strong>3. Multi-User AI Context Management</strong></p>
                <ul>
                    <li>Isolate user contexts using partition keys (<code>userId</code>)</li>
                    <li>Store user-specific knowledge and preferences as vectors</li>
                    <li>Provide personalized AI experiences at scale</li>
                </ul>

                <h3>üåê Web and Business Applications</h3>

                <p><strong>4. Recommendation Engines</strong></p>
                <ul>
                    <li>Convert product descriptions into vectors</li>
                    <li>Find similar products based on features</li>
                    <li>Recommend items based on user behavior embeddings</li>
                </ul>

                <p><strong>5. Semantic Product Search</strong></p>
                <ul>
                    <li>Search catalogs by meaning: "comfortable running shoes" finds relevant products</li>
                    <li>No need for exact keyword matches</li>
                    <li>Improves user experience and conversion rates</li>
                </ul>

                <p><strong>6. Content Discovery</strong></p>
                <ul>
                    <li>Find similar articles, videos, or documents</li>
                    <li>"More like this" features</li>
                    <li>Cross-language similarity (multilingual embeddings)</li>
                </ul>

                <h3>üìä Analytics and Insights</h3>

                <p><strong>7. Duplicate Detection</strong></p>
                <ul>
                    <li>Identify duplicate or near-duplicate content</li>
                    <li>Find similar customer support tickets</li>
                    <li>Deduplication workflows</li>
                </ul>

                <p><strong>8. Clustering and Classification</strong></p>
                <ul>
                    <li>Group similar documents or user profiles</li>
                    <li>Segment customers by behavior patterns</li>
                    <li>Anomaly detection (outliers in vector space)</li>
                </ul>

                <h2 id="vs-how-it-works">How It Works</h2>

                <h3>Architecture Overview</h3>

                <div class="mermaid">
                %%{init: {'theme':'base', 'themeVariables': {'fontFamily':'Segoe UI'}, 'flowchart': {'nodeSpacing': 40, 'rankSpacing': 60}}}%%
                flowchart TB
                    Input["üìù Input Text: 
                'AI-powered database'"]
                    
                    Model["ü§ñ AI Embedding Model 
                (OpenAI, Azure OpenAI, etc.)"]
                    
                    Vector["üî¢ Vector Embedding 
                [0.12, -0.45, 0.78, ...]"]
                    
                    Store["üíæ Store in Cosmos DB 
                with application data"]
                    
                    Query["üîç User Query: 
                'intelligent data storage'"]
                    
                    QueryVector["üî¢ Query Embedding 
                [0.15, -0.42, 0.81, ...]"]
                    
                    VectorSearch["‚ö° Vector Similarity Search 
                Find closest vectors"]
                    
                    Results["‚úÖ Results: 
                Most relevant documents"]
                    
                    Input --> Model
                    Model --> Vector
                    Vector --> Store
                    
                    Query --> Model
                    Model --> QueryVector
                    QueryVector --> VectorSearch
                    Store --> VectorSearch
                    VectorSearch --> Results
                    
                    style Model fill:#50E6FF,stroke:#0078D4,color:#000
                    style Store fill:#0078D4,stroke:#005A9E,color:#fff
                    style VectorSearch fill:#B7D332,stroke:#8AA000,color:#000
                    style Results fill:#90EE90,stroke:#32CD32,color:#000
                </div>

                <h3>Storage Model</h3>

                <p>Vectors are stored alongside your regular document properties:</p>

                <pre><code>{
        "id": "doc-123",
        "userId": "user-456",
        "title": "Azure Cosmos DB Overview",
        "content": "Azure Cosmos DB is a globally distributed...",
        "contentVector": [0.12, -0.34, 0.89, 0.45, ..., 0.67],  // 1536 dimensions
        "createdAt": "2025-12-08T10:00:00Z",
        "tags": ["database", "nosql", "azure"]
    }</code></pre>

                <h3>Indexing Policy</h3>

                <p>Configure vector indexing in your container's indexing policy:</p>

                <pre><code>{
        "vectorIndexes": [
            {
                "path": "/contentVector",
                "type": "quantizedFlat",  // or "diskANN" for larger datasets
                "dimensions": 1536,
                "distanceFunction": "cosine"  // or "euclidean", "dotProduct"
            }
        ]
    }</code></pre>

                <p><strong>Index Types:</strong></p>
                <ul>
                    <li><strong>quantizedFlat</strong>: Best for &lt;100K vectors, lowest latency, higher memory usage</li>
                    <li><strong>diskANN</strong>: Best for millions/billions of vectors, scalable, efficient disk-based indexing</li>
                </ul>

                <p><strong>Distance Functions:</strong></p>
                <ul>
                    <li><strong>cosine</strong>: Most common, measures angle between vectors (range: -1 to 1)</li>
                    <li><strong>euclidean</strong>: Straight-line distance</li>
                    <li><strong>dotProduct</strong>: Inner product, useful for normalized vectors</li>
                </ul>

                <h3>Query Example</h3>

                <p>Use the SQL API to perform vector similarity searches:</p>

                <pre><code>SELECT TOP 10 
        c.id, 
        c.title, 
        VectorDistance(c.contentVector, @queryVector) AS similarity
    FROM c
    WHERE c.userId = "user-456"  -- Partition key for efficiency
    ORDER BY VectorDistance(c.contentVector, @queryVector)
    </code></pre>

                <p><strong>Key Points:</strong></p>
                <ul>
                    <li><code>@queryVector</code> is the embedding of your search query</li>
                    <li>Include partition key (<code>userId</code>) for low-latency single-partition queries</li>
                    <li>Results ordered by similarity (closest vectors first)</li>
                    <li>Typical RU cost: 5-20 RU for single-partition vector search</li>
                </ul>

                <h2 id="vector-search-vs-alternatives">Vector Search vs Alternatives</h2>

                <h3>Cosmos DB vs Dedicated Vector Databases</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Cosmos DB Vector Search</th>
                            <th>Dedicated Vector DB (Pinecone, Weaviate, etc.)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Data Model</strong></td>
                            <td>Unified: vectors + operational data</td>
                            <td>Separate: vectors only, need sync with main DB</td>
                        </tr>
                        <tr>
                            <td><strong>Cost</strong></td>
                            <td>üí∞ Lower (shared RU/s, no extra service)</td>
                            <td>üí∞üí∞ Higher (separate service + storage)</td>
                        </tr>
                        <tr>
                            <td><strong>Latency</strong></td>
                            <td>‚ö° Low (&lt; 10ms with partition key)</td>
                            <td>‚ö°‚ö° Very low (optimized for vectors only)</td>
                        </tr>
                        <tr>
                            <td><strong>Scale</strong></td>
                            <td>Billions of vectors, horizontal scaling</td>
                            <td>Billions of vectors, optimized indexing</td>
                        </tr>
                        <tr>
                            <td><strong>Global Distribution</strong></td>
                            <td>‚úÖ Built-in multi-region replication</td>
                            <td>‚ùå Often single-region or limited replication</td>
                        </tr>
                        <tr>
                            <td><strong>Operational Complexity</strong></td>
                            <td>‚úÖ Simple (one service)</td>
                            <td>‚ùå Complex (multiple services to sync)</td>
                        </tr>
                        <tr>
                            <td><strong>Transaction Support</strong></td>
                            <td>‚úÖ ACID within partition</td>
                            <td>‚ùå Limited or no transactions</td>
                        </tr>
                        <tr>
                            <td><strong>Best For</strong></td>
                            <td>RAG, chat apps, contextual AI, recommendations</td>
                            <td>Pure vector workloads, very large-scale vector-only apps</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to Choose Cosmos DB Vector Search</h3>

                <p><strong>‚úÖ Use Cosmos DB for Vector Search when:</strong></p>
                <ul>
                    <li>You need vectors <strong>alongside operational data</strong> (chat history, user profiles, orders)</li>
                    <li>Building <strong>RAG applications</strong> with AI/LLMs</li>
                    <li>Cost efficiency is important (avoid separate vector DB service)</li>
                    <li>You need <strong>global distribution</strong> and multi-region writes</li>
                    <li>Transactional consistency matters</li>
                    <li>Workload is &lt; 1 billion vectors per container</li>
                </ul>

                <p><strong>‚ùå Consider Dedicated Vector DB when:</strong></p>
                <ul>
                    <li>Pure vector-only workload with billions of vectors</li>
                    <li>Need ultra-specialized vector indexing (e.g., HNSW with extreme tuning)</li>
                    <li>No operational data to store‚Äîjust embeddings</li>
                </ul>

                <h2 id="vs-integration-benefits">Integration Benefits</h2>

                <h3>Unified Data Platform</h3>

                <p>Store everything in one place:</p>

                <pre><code>{
        "id": "chat-msg-789",
        "userId": "user-456",
        "sessionId": "session-001",
        "role": "user",
        "message": "How do I deploy Cosmos DB?",
        "messageVector": [0.12, -0.34, ...],  // Semantic search
        "timestamp": "2025-12-08T15:30:00Z",
        "sentiment": "neutral",
        "language": "en"
    }</code></pre>

                <p><strong>Benefits:</strong></p>
                <ul>
                    <li>‚úÖ <strong>No ETL pipelines</strong> to sync data between vector DB and operational DB</li>
                    <li>‚úÖ <strong>Consistent schema</strong> and data model</li>
                    <li>‚úÖ <strong>Single query</strong> retrieves vectors + metadata</li>
                    <li>‚úÖ <strong>Lower costs</strong>: one database service instead of two</li>
                </ul>

                <h3>AI Application Patterns</h3>

                <p><strong>1. Contextual AI with Partition Keys</strong></p>

                <pre><code>// User-specific context isolation
    Partition Key: /userId

    // Each user's data is isolated
    Query: "Find similar conversations for user-456"
    ‚Üì
    SELECT TOP 5 c.message, VectorDistance(c.messageVector, @query) AS score
    FROM c
    WHERE c.userId = "user-456"  // Single partition = fast + cheap
    ORDER BY VectorDistance(c.messageVector, @query)</code></pre>

                <p><strong>2. Multi-Tenant RAG Applications</strong></p>

                <pre><code>// Tenant-specific knowledge base
    Partition Key: /tenantId

    // Each tenant's knowledge is isolated
    Query: "Find relevant docs for tenant-ABC"
    ‚Üì
    SELECT c.id, c.title, c.content
    FROM c
    WHERE c.tenantId = "tenant-ABC" 
    AND VectorDistance(c.contentVector, @query) < 0.8</code></pre>

                <h3>Change Feed Integration</h3>

                <p>Automatically update vector embeddings when data changes:</p>

                <ol>
                    <li>Document created/updated in Cosmos DB</li>
                    <li>Change Feed triggers Azure Function</li>
                    <li>Function generates vector embedding (calls OpenAI API)</li>
                    <li>Function updates document with new <code>contentVector</code></li>
                </ol>

                <p><strong>Benefit:</strong> Keep embeddings in sync with source data automatically.</p>

                <h2 id="vector-search-best-practices">Best Practices</h2>

                <h3>Design Guidelines</h3>

                <p><strong>1. Partition Key Strategy</strong></p>
                <ul>
                    <li>‚úÖ <strong>DO</strong>: Use partition keys that align with query patterns (<code>userId</code>, <code>tenantId</code>)</li>
                    <li>‚úÖ <strong>DO</strong>: Scope vector searches to single partition for low latency</li>
                    <li>‚ùå <strong>AVOID</strong>: Cross-partition vector searches (high RU cost)</li>
                </ul>

                <p><strong>2. Embedding Model Selection</strong></p>
                <ul>
                    <li>‚úÖ Use <strong>Azure OpenAI</strong> for enterprise-grade embeddings</li>
                    <li>‚úÖ Consider <strong>smaller models</strong> (384-768 dims) for cost efficiency if accuracy permits</li>
                    <li>‚úÖ Use <strong>consistent model</strong> for queries and data (don't mix models)</li>
                </ul>

                <p><strong>3. Indexing Configuration</strong></p>
                <ul>
                    <li>Use <code>quantizedFlat</code> for &lt; 100K vectors (faster, higher memory)</li>
                    <li>Use <code>diskANN</code> for millions of vectors (scalable, disk-based)</li>
                    <li>Choose <code>cosine</code> distance for most text embeddings</li>
                </ul>

                <p><strong>4. Query Optimization</strong></p>
                <ul>
                    <li>‚úÖ Always include partition key in WHERE clause</li>
                    <li>‚úÖ Use <code>TOP N</code> to limit results</li>
                    <li>‚úÖ Filter by distance threshold to reduce results: <code>WHERE VectorDistance(...) < 0.8</code></li>
                    <li>‚úÖ Project only needed fields to reduce RU cost</li>
                </ul>

                <p><strong>5. Cost Management</strong></p>
                <ul>
                    <li>Monitor RU consumption for vector queries (typically 5-20 RU)</li>
                    <li>Batch embedding generation to reduce API calls</li>
                    <li>Cache frequently accessed embeddings</li>
                    <li>Use autoscale throughput for variable workloads</li>
                </ul>

                <h2 id="vector-search-summary">Summary</h2>

                <div class="callout">
                    <p><strong>Key Takeaways: Vector Search in Cosmos DB</strong></p>
                    <ol>
                        <li><strong>Unified Storage</strong>: Store vectors and operational data together‚Äîno separate vector DB needed</li>
                        <li><strong>Cost-Effective</strong>: Lower cost than dedicated vector databases for most AI applications</li>
                        <li><strong>AI-Ready</strong>: Perfect for RAG, chat history, recommendations, semantic search</li>
                        <li><strong>Scalable</strong>: Handles billions of vectors with horizontal partitioning</li>
                        <li><strong>Fast</strong>: Low-latency queries (&lt; 10ms) with proper partition key usage</li>
                        <li><strong>Global</strong>: Vectors replicate across regions automatically</li>
                        <li><strong>Integrated</strong>: Works with Change Feed, triggers, and other Cosmos DB features</li>
                        <li><strong>Simple</strong>: Use familiar SQL API for vector similarity queries</li>
                    </ol>
                </div>

                <h3>Use Cases Summary</h3>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Use Case</th>
                            <th>Why Cosmos DB Vector Search</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>RAG Applications</strong></td>
                            <td>Store docs + vectors together, fast context retrieval</td>
                        </tr>
                        <tr>
                            <td><strong>Chat History</strong></td>
                            <td>Semantic search over conversations, user isolation</td>
                        </tr>
                        <tr>
                            <td><strong>Recommendations</strong></td>
                            <td>Product embeddings + metadata in one query</td>
                        </tr>
                        <tr>
                            <td><strong>Multi-User AI</strong></td>
                            <td>Partition per user for fast, isolated context</td>
                        </tr>
                        <tr>
                            <td><strong>Semantic Search</strong></td>
                            <td>Find by meaning, not keywords</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Additional Resources</h3>

                <ul class="list-style-none">
                    <li><a href="https://learn.microsoft.com/azure/cosmos-db/vector-search" target="_blank">Azure Cosmos DB Vector Search Documentation</a></li>
                    <li><a href="https://learn.microsoft.com/azure/cosmos-db/nosql/vector-search" target="_blank">Vector Search for NoSQL API</a></li>
                    <li><a href="https://learn.microsoft.com/azure/ai-services/openai/concepts/embeddings" target="_blank">Azure OpenAI Embeddings</a></li>
                    <li><a href="https://github.com/Azure-Samples/cosmosdb-nosql-copilot" target="_blank">Sample: RAG with Cosmos DB Vector Search</a></li>
                </ul>

            </section>

            <section id="cosmosdb-resources" role="article">
            <h1>Resources</h1>
            <span class="badge">docs, community</span>
            
            <h2>Official Resources</h2>
            <ul class="list-style-none">
                <li><a href="https://learn.microsoft.com/azure/cosmos-db/" target="_blank">Azure Cosmos DB Documentation</a></li>
                <li><a href="https://learn.microsoft.com/azure/cosmos-db/sql/" target="_blank">SQL API Documentation</a></li>
                <li><a href="https://learn.microsoft.com/azure/cosmos-db/tutorials" target="_blank">Tutorials and Quickstarts</a></li>
                <li><a href="https://learn.microsoft.com/azure/cosmos-db/pricing" target="_blank">Pricing Information</a></li>
                <li><a href="https://learn.microsoft.com/azure/cosmos-db/support-and-troubleshooting" target="_blank">Support and Troubleshooting</a></li>
            </ul>

            <h2>Key Takeaways</h2>
            <div class="callout">
                <ol>
                    <li>Comprehensive official documentation available</li>
                    <li>Tutorials for hands-on learning</li>
                    <li>Clear pricing details to plan costs</li>
                    <li>Robust support resources for troubleshooting</li>
                    <li>Community and sample code for practical insights</li>
                </ol>
            </div>

            <h2>Getting Help</h2>
            <ul class="list-style-none">
                <li><a href="https://stackoverflow.com/questions/tagged/azure-cosmosdb" target="_blank">Stack Overflow - Azure Cosmos DB</a></li>
                <li><a href="https://techcommunity.microsoft.com/t5/azure-database-services/bd-p/AzureDatabaseServices" target="_blank">Microsoft Tech Community - Azure Database Services</a></li>
                <li><a href="https://github.com/Azure/azure-cosmosdb-js-server" target="_blank">Server-Side Programming Samples</a></li>
            </ul>
            </section>
            </div>
        </main>
        </div>
        
        <nav class="controls" role="navigation" aria-label="Pagination">
        <div class="btn-group" role="group">
            <button class="btn btn-outline-info btn-sm" id="prevBtn" title="Previous" aria-label="Previous concept">&nbsp;&lt;&nbsp;</button>
            <button class="btn btn-outline-info btn-sm" id="nextBtn" title="Next" aria-label="Next concept">&nbsp;&gt;&nbsp;</button>
        </div>
        </nav>
    </div>  <div class="offcanvas offcanvas-start" tabindex="-1" id="sidebarOffcanvas" aria-labelledby="sidebarLabel">
        <div class="offcanvas-header">
        <h5 class="offcanvas-title" id="sidebarLabel">Contents</h5>
        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body p-0">
        <ul class="list-group list-group-flush w-100" id="tocMobile"></ul>
        </div>
    </div>

    <script>
        // - Mermaid Initialization -
        document.addEventListener('DOMContentLoaded', () => {
        if (window.mermaid) {
            window.mermaid.contentLoaded();
        }
        });

        // - Configuration -
        const sectionConfig = [
        { id: "cosmosdb-concepts", title: "Cosmos DB Concepts", tags: ["intro", "overview", "concepts"] },
        { id: "cosmosdb-data-modelling", title: "Data Modelling", tags: ["modeling", "partition-keys", "design"] },
        { id: "cosmosdb-querying-data", title: "Querying Data", tags: ["queries", "sql", "nosql"] },
        { id: "cosmosdb-query-performance", title: "Query Performance", tags: ["performance", "optimization", "RUs"] },
        { id: "cosmosdb-server-side-programming", title: "Server-Side Programming", tags: ["stored-procedures", "triggers", "UDFs"] },
        { id: "cosmosdb-vector-search", title: "Vector Search & AI", tags: ["AI", "vector-search", "embeddings", "RAG"] },
        { id: "cosmosdb-resources", title: "Resources", tags: ["docs", "community", "links"] }
        ];

        // - State & rendering -
        const state = {
        index: 0,
        filtered: sectionConfig.map((_, i) => i), // indices
        };

        const els = {
        toc: document.getElementById('toc'),
        tocMobile: document.getElementById('tocMobile'),
        prev: document.getElementById('prevBtn'),
        next: document.getElementById('nextBtn'),
        toggleSidebar: document.getElementById('toggleSidebar'),
        themeToggle: document.getElementById('themeToggle'),
        main: document.getElementById('main'),
        sidebar: document.querySelector('nav.sidebar'),
        sidebarOffcanvas: document.getElementById('sidebarOffcanvas')
        };

        function buildTOC(){
        // Clear both TOC lists
        els.toc.innerHTML = '';
        els.tocMobile.innerHTML = '';
        
        state.filtered.forEach((idx) => {
            const s = sectionConfig[idx];
            
            // Desktop sidebar
            const liDesktop = document.createElement('li');
            liDesktop.className = 'list-group-item';
            const aDesktop = document.createElement('a');
            aDesktop.href = `#${s.id}`;
            aDesktop.textContent = s.title;
            aDesktop.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToId(s.id);
            closeSidebar();
            });
            liDesktop.appendChild(aDesktop);
            els.toc.appendChild(liDesktop);
            
            // Mobile offcanvas
            const liMobile = document.createElement('li');
            liMobile.className = 'list-group-item';
            const aMobile = document.createElement('a');
            aMobile.href = `#${s.id}`;
            aMobile.textContent = s.title;
            aMobile.addEventListener('click', (e) => {
            e.preventDefault();
            navigateToId(s.id);
            closeSidebar();
            });
            liMobile.appendChild(aMobile);
            els.tocMobile.appendChild(liMobile);
        });
        highlightActiveTOC();
        }

        function setActiveByIndex(i){
        const ids = state.filtered.map(idx => sectionConfig[idx].id);
        document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
        const id = ids[i];
        const active = document.getElementById(id);
        if (active){
            active.classList.add('active');
            active.setAttribute('tabindex', '-1');
            active.focus({preventScroll:true});
        }
        updateControls();
        highlightActiveTOC();
        updateURLHash(id);
        }

        function updateControls(){
        const count = state.filtered.length;
        els.prev.disabled = state.index <= 0;
        els.next.disabled = state.index >= count - 1;
        }

        function filterTOC(query){
        const q = query.trim().toLowerCase();
        state.filtered = sectionConfig
            .map((s, i) => ({s, i}))
            .filter(({s}) => s.title.toLowerCase().includes(q) || s.tags.some(t => t.toLowerCase().includes(q)))
            .map(({i}) => i);

        state.index = Math.min(state.index, Math.max(0, state.filtered.length - 1));
        buildTOC();
        setActiveByIndex(state.index);
        }

        function navigate(delta){
        const count = state.filtered.length;
        const nextIndex = Math.min(Math.max(state.index + delta, 0), count - 1);
        if (nextIndex !== state.index){
            state.index = nextIndex;
            setActiveByIndex(state.index);
            // Scroll content to top
            const contentEl = document.querySelector('.content');
            if (contentEl) contentEl.scrollTop = 0;
        }
        }

        function navigateToId(id){
        const idxInFiltered = state.filtered.findIndex(fi => sectionConfig[fi].id === id);
        if (idxInFiltered !== -1){
            state.index = idxInFiltered;
            setActiveByIndex(state.index);
            // Scroll content to top
            const contentEl = document.querySelector('.content');
            if (contentEl) contentEl.scrollTop = 0;
        } else {
            state.filtered = sectionConfig.map((_, i) => i);
            buildTOC();
            navigateToId(id);
        }
        }

        function updateURLHash(id){
        const url = new URL(window.location);
        url.hash = id;
        history.replaceState(null, '', url);
        }

        function highlightActiveTOC(){
        const ids = state.filtered.map(idx => sectionConfig[idx].id);
        const activeId = ids[state.index];
        // Highlight desktop sidebar
        els.toc.querySelectorAll('a').forEach(a => a.classList.toggle('active', a.getAttribute('href') === `#${activeId}`));
        // Highlight mobile offcanvas
        els.tocMobile.querySelectorAll('a').forEach(a => a.classList.toggle('active', a.getAttribute('href') === `#${activeId}`));
        }

        function openSidebar(){
        const offcanvas = new bootstrap.Offcanvas(document.getElementById('sidebarOffcanvas'));
        offcanvas.show();
        }
        function closeSidebar(){
        const offcanvasElement = document.getElementById('sidebarOffcanvas');
        const offcanvas = bootstrap.Offcanvas.getInstance(offcanvasElement);
        if(offcanvas) offcanvas.hide();
        }

        // - Events -
        els.prev.addEventListener('click', () => navigate(-1));
        els.next.addEventListener('click', () => navigate(1));

        // Keyboard navigation
        window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') navigate(-1);
        else if (e.key === 'ArrowRight') navigate(1);
        else if (e.key === 'Escape') closeSidebar();
        });

        // Deep linking on load/hash change
        window.addEventListener('hashchange', () => {
        const id = location.hash.replace('#','');
        if (id) navigateToId(id);
        });

        // Sidebar toggle (mobile)
        els.toggleSidebar.addEventListener('click', () => {
        openSidebar();
        });

        // Restore theme
        (function(){
        try {
            const saved = localStorage.getItem('concepts-theme');
            if (saved) { 
            document.documentElement.setAttribute('data-theme', saved);
            els.themeToggle.textContent = saved === 'light' ? 'üåó' : 'üåô';
            }
        } catch {}
        })();

        // Initial render
        buildTOC();
        setActiveByIndex(0);

        // Navigate to hash if present
        const initialId = location.hash.replace('#','');
        if (initialId){ navigateToId(initialId); }

    </script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    </body>
    </html>